// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(bedrockFFI)
import bedrockFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bedrock_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bedrock_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureBedrockInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Global configuration for Bedrock
 */
public protocol BedrockConfigProtocol: AnyObject, Sendable {
    
    /**
     * Gets the current environment
     */
    func environment()  -> BedrockEnvironment
    
}
/**
 * Global configuration for Bedrock
 */
open class BedrockConfig: BedrockConfigProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_bedrockconfig(self.pointer, $0) }
    }
    /**
     * Creates a new BedrockConfig with the specified environment
     *
     * # Arguments
     * * `environment` - The environment to use for this configuration
     *
     * # Examples
     *
     * ## Swift
     *
     * ```swift
     * let config = BedrockConfig(environment: .production)
     * ```
     */
public convenience init(environment: BedrockEnvironment) {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_bedrockconfig_new(
        FfiConverterTypeBedrockEnvironment_lower(environment),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_bedrockconfig(pointer, $0) }
    }

    

    
    /**
     * Gets the current environment
     */
open func environment() -> BedrockEnvironment  {
    return try!  FfiConverterTypeBedrockEnvironment_lift(try! rustCall() {
    uniffi_bedrock_fn_method_bedrockconfig_environment(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBedrockConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BedrockConfig

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockConfig {
        return BedrockConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BedrockConfig) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BedrockConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BedrockConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockConfig {
    return try FfiConverterTypeBedrockConfig.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockConfig_lower(_ value: BedrockConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBedrockConfig.lower(value)
}






/**
 * A wrapper around hex-encoded bytes (may or may not be a number).
 *
 * This is used to ensure that the hex string is properly formatted and the output is always prefixed with "0x".
 * Ensures consistency in expected output format.
 *
 * # Examples
 * ```
 * use bedrock::primitives::HexEncodedData;
 * let hex_string = HexEncodedData::new("0x1234567890abcdef");
 * ```
 */
public protocol HexEncodedDataProtocol: AnyObject, Sendable {
    
    /**
     * Returns the wrapped hex string as a String. Re-wraps `Display` trait for foreign code.
     */
    func toHexString()  -> String
    
    /**
     * Converts the wrapped hex string into a `Bytes` struct.
     *
     * # Errors
     * - `PrimitiveError::Generic` in the unexpected case that the hex string is not validly encoded hex data.
     * This should never happen as this is verified on initialization.
     */
    func toVec() throws  -> Data
    
}
/**
 * A wrapper around hex-encoded bytes (may or may not be a number).
 *
 * This is used to ensure that the hex string is properly formatted and the output is always prefixed with "0x".
 * Ensures consistency in expected output format.
 *
 * # Examples
 * ```
 * use bedrock::primitives::HexEncodedData;
 * let hex_string = HexEncodedData::new("0x1234567890abcdef");
 * ```
 */
open class HexEncodedData: HexEncodedDataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_hexencodeddata(self.pointer, $0) }
    }
    /**
     * Initializes a new `HexEncodedData` from a hex string.
     *
     * # Arguments
     * * `s` - The hex string to initialize the `HexEncodedData` from. May or may not be prefixed with "0x".
     *
     * # Errors
     * - `PrimitiveError::InvalidHexString` if the provided string is not validly encoded hex data.
     */
public convenience init(s: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePrimitiveError_lift) {
    uniffi_bedrock_fn_constructor_hexencodeddata_new(
        FfiConverterString.lower(s),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_hexencodeddata(pointer, $0) }
    }

    

    
    /**
     * Returns the wrapped hex string as a String. Re-wraps `Display` trait for foreign code.
     */
open func toHexString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bedrock_fn_method_hexencodeddata_to_hex_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Converts the wrapped hex string into a `Bytes` struct.
     *
     * # Errors
     * - `PrimitiveError::Generic` in the unexpected case that the hex string is not validly encoded hex data.
     * This should never happen as this is verified on initialization.
     */
open func toVec()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypePrimitiveError_lift) {
    uniffi_bedrock_fn_method_hexencodeddata_to_vec(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHexEncodedData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HexEncodedData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HexEncodedData {
        return HexEncodedData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HexEncodedData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HexEncodedData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HexEncodedData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHexEncodedData_lift(_ pointer: UnsafeMutableRawPointer) throws -> HexEncodedData {
    return try FfiConverterTypeHexEncodedData.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHexEncodedData_lower(_ value: HexEncodedData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHexEncodedData.lower(value)
}






/**
 * Trait representing a logger that can log messages at various levels.
 *
 * This trait should be implemented by any logger that wants to receive log messages.
 * It is exported via `UniFFI` for use in foreign languages.
 *
 * # Examples
 *
 * Implementing the `Logger` trait:
 *
 * ```rust
 *
 * use bedrock::primitives::logger::{Logger, LogLevel};
 *
 * struct MyLogger;
 *
 * impl Logger for MyLogger {
 * fn log(&self, level: LogLevel, message: String) {
 * println!("[{:?}] {}", level, message);
 * }
 * }
 * ```
 *
 * ## swift
 *
 * ```swift
 * class BedrockCoreLoggerBridge: Bedrock.Logger {
 * static let shared = BedrockCoreLoggerBridge()
 *
 * func log(level: Bedrock.LogLevel, message: String) {
 * Log.log(level.toCoreLevel(), message)
 * }
 * }
 *
 * public func setupBedrockLogger() {
 * Bedrock.setLogger(logger: BedrockCoreLoggerBridge.shared)
 * }
 *
 * extension Bedrock.LogLevel {
 * func toCoreLevel() -> WorldAppCore.LogLevel {
 * switch self {
 * case .debug, .trace:
 * return .debug
 * case .info:
 * return .info
 * case .error:
 * return .error
 * case .warn:
 * return .warn
 * }
 * }
 * }
 * ```
 *
 * ### In app delegate
 *
 * ```swift
 * setupBedrockLogger() // Call this only once!!!
 * ```
 */
public protocol Logger: AnyObject, Sendable {
    
    /**
     * Logs a message at the specified log level.
     *
     * # Arguments
     *
     * * `level` - The severity level of the log message.
     * * `message` - The log message to be recorded.
     */
    func log(level: LogLevel, message: String) 
    
}
/**
 * Trait representing a logger that can log messages at various levels.
 *
 * This trait should be implemented by any logger that wants to receive log messages.
 * It is exported via `UniFFI` for use in foreign languages.
 *
 * # Examples
 *
 * Implementing the `Logger` trait:
 *
 * ```rust
 *
 * use bedrock::primitives::logger::{Logger, LogLevel};
 *
 * struct MyLogger;
 *
 * impl Logger for MyLogger {
 * fn log(&self, level: LogLevel, message: String) {
 * println!("[{:?}] {}", level, message);
 * }
 * }
 * ```
 *
 * ## swift
 *
 * ```swift
 * class BedrockCoreLoggerBridge: Bedrock.Logger {
 * static let shared = BedrockCoreLoggerBridge()
 *
 * func log(level: Bedrock.LogLevel, message: String) {
 * Log.log(level.toCoreLevel(), message)
 * }
 * }
 *
 * public func setupBedrockLogger() {
 * Bedrock.setLogger(logger: BedrockCoreLoggerBridge.shared)
 * }
 *
 * extension Bedrock.LogLevel {
 * func toCoreLevel() -> WorldAppCore.LogLevel {
 * switch self {
 * case .debug, .trace:
 * return .debug
 * case .info:
 * return .info
 * case .error:
 * return .error
 * case .warn:
 * return .warn
 * }
 * }
 * }
 * ```
 *
 * ### In app delegate
 *
 * ```swift
 * setupBedrockLogger() // Call this only once!!!
 * ```
 */
open class LoggerImpl: Logger, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_logger(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_logger(pointer, $0) }
    }

    

    
    /**
     * Logs a message at the specified log level.
     *
     * # Arguments
     *
     * * `level` - The severity level of the log message.
     * * `message` - The log message to be recorded.
     */
open func log(level: LogLevel, message: String)  {try! rustCall() {
    uniffi_bedrock_fn_method_logger_log(self.uniffiClonePointer(),
        FfiConverterTypeLogLevel_lower(level),
        FfiConverterString.lower(message),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLogger] = [UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            level: RustBuffer,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     level: try FfiConverterTypeLogLevel_lift(level),
                     message: try FfiConverterString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLogger() {
    uniffi_bedrock_fn_init_callback_vtable_logger(UniffiCallbackInterfaceLogger.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogger: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Logger>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Logger

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
        return LoggerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Logger) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Logger {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Logger, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
    return try FfiConverterTypeLogger.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lower(_ value: Logger) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogger.lower(value)
}






/**
 * A Safe Smart Account (previously Gnosis Safe) is the representation of a Safe smart contract.
 *
 * It is used to sign messages, transactions and typed data on behalf of the Safe smart contract.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account>
 */
public protocol SafeSmartAccountProtocol: AnyObject, Sendable {
    
    /**
     * Signs a string message using the `personal_sign` method on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `message`: The message to sign. Do not add the EIP-191 prefix, or typehash prefixes. Should be the raw message.
     *
     * # Errors
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func personalSign(chainId: UInt32, message: String) throws  -> HexEncodedData
    
    /**
     * Crafts and signs a 4337 user operation on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the user operation is being signed.
     * - `user_operation`: The user operation to sign.
     *
     * # Errors
     * - Will throw an error if the user operation is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     *
     * # Examples
     * ```rust
     * use bedrock::smart_account::{UserOperation, SafeSmartAccount};
     *
     * let safe = SafeSmartAccount::new(
     * // this is Anvil's default private key, it is a test secret
     * "ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80".to_string(),
     * "0x4564420674EA68fcc61b463C0494807C759d47e6",
     * )
     * .unwrap();
     *
     * // This would normally be crafted by the user, or requested by Mini Apps.
     * let user_op = UserOperation {
     * sender:"0xf1390a26bd60d83a4e38c7be7be1003c616296ad".to_string(),
     * nonce: "0xb14292cd79fae7d79284d4e6304fb58e21d579c13a75eed80000000000000000".to_string(),
     * call_data:  "0x7bb3742800000000000000000000000079a02482a880bce3f13e09da970dc34db4cd24d10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ce2111f9ab8909b71ebadc9b6458daefe069eda4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000".to_string(),
     * signature:  "0x000012cea6000000967a7600ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".to_string(),
     * call_gas_limit: "0xabb8".to_string(),
     * verification_gas_limit: "0xfa07".to_string(),
     * pre_verification_gas: "0x8e4d78".to_string(),
     * max_fee_per_gas: "0x1af6f".to_string(),
     * max_priority_fee_per_gas: "0x1adb0".to_string(),
     * paymaster: Some("0xEF725Aa22d43Ea69FB22bE2EBe6ECa205a6BCf5B".to_string()),
     * paymaster_verification_gas_limit: "0x7415".to_string(),
     * paymaster_post_op_gas_limit: "0x".to_string(),
     * paymaster_data: Some("000000000000000067789a97c4af0f8ae7acc9237c8f9611a0eb4662009d366b8defdf5f68fed25d22ca77be64b8eef49d917c3f8642ca539571594a84be9d0ee717c099160b79a845bea2111b".to_string()),
     * factory: None,
     * factory_data: None,
     * };
     *
     * let signature = safe.sign_4337_op(480, &user_op).unwrap();
     *
     * println!("Signature: {}", signature.to_hex_string());
     * ```
     */
    func sign4337Op(chainId: UInt32, userOperation: UserOperation) throws  -> HexEncodedData
    
    /**
     * Signs a `Permit2` transfer on behalf of the Safe Smart Account.
     *
     * Used by Mini Apps where users approve transfers for specific tokens and amounts for a period of time on their behalf.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed.
     * - `transfer`: The `Permit2` transfer to sign.
     *
     * # Errors
     * - Will throw an error if the transfer is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signPermit2Transfer(chainId: UInt32, transfer: Permit2TransferFrom) throws  -> HexEncodedData
    
    /**
     * Signs a transaction on behalf of the Safe Smart Account.
     *
     * This allows execution of normal transactions for the Safe.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the transaction is being signed.
     * - `transaction`: The transaction to sign.
     *
     * # Errors
     * - Will throw an error if the transaction is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signTransaction(chainId: UInt32, transaction: SafeTransaction) throws  -> HexEncodedData
    
    /**
     * Signs an arbitrary EIP-712 typed data message on behalf of the Safe Smart Account.
     *
     * Please note that certain primary types are restricted and cannot be signed. For example Permit2's `PermitTransferFrom` is restricted.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `stringified_typed_data`: A JSON string representing the typed data as per EIP-712.
     *
     * # Errors
     * - Will throw an error if the typed data is not a valid JSON string.
     * - Will throw an error if the typed data is not a valid EIP-712 typed data message.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signTypedData(chainId: UInt32, stringifiedTypedData: String) throws  -> HexEncodedData
    
}
/**
 * A Safe Smart Account (previously Gnosis Safe) is the representation of a Safe smart contract.
 *
 * It is used to sign messages, transactions and typed data on behalf of the Safe smart contract.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account>
 */
open class SafeSmartAccount: SafeSmartAccountProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_safesmartaccount(self.pointer, $0) }
    }
    /**
     * Initializes a new `SafeSmartAccount` instance with the given EOA signing key.
     *
     * # Arguments
     * - `private_key`: A hex-encoded string representing the **secret key** of the EOA who is an owner in the Safe.
     * - `wallet_address`: The address of the Safe Smart Account (i.e. the deployed smart contract). This is required because
     * some legacy versions of the wallet were computed differently. Today, it cannot be deterministically computed for all
     * users. This is also necessary to support signing for Safes deployed by third-party Mini App devs, where the
     * wallet address is only known at runtime.
     *
     * # Errors
     * - Will return an error if the key is not a validly encoded hex string.
     * - Will return an error if the key is not a valid point in the k256 curve.
     */
public convenience init(privateKey: String, walletAddress: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_constructor_safesmartaccount_new(
        FfiConverterString.lower(privateKey),
        FfiConverterString.lower(walletAddress),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_safesmartaccount(pointer, $0) }
    }

    

    
    /**
     * Signs a string message using the `personal_sign` method on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `message`: The message to sign. Do not add the EIP-191 prefix, or typehash prefixes. Should be the raw message.
     *
     * # Errors
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func personalSign(chainId: UInt32, message: String)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_personal_sign(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Crafts and signs a 4337 user operation on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the user operation is being signed.
     * - `user_operation`: The user operation to sign.
     *
     * # Errors
     * - Will throw an error if the user operation is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     *
     * # Examples
     * ```rust
     * use bedrock::smart_account::{UserOperation, SafeSmartAccount};
     *
     * let safe = SafeSmartAccount::new(
     * // this is Anvil's default private key, it is a test secret
     * "ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80".to_string(),
     * "0x4564420674EA68fcc61b463C0494807C759d47e6",
     * )
     * .unwrap();
     *
     * // This would normally be crafted by the user, or requested by Mini Apps.
     * let user_op = UserOperation {
     * sender:"0xf1390a26bd60d83a4e38c7be7be1003c616296ad".to_string(),
     * nonce: "0xb14292cd79fae7d79284d4e6304fb58e21d579c13a75eed80000000000000000".to_string(),
     * call_data:  "0x7bb3742800000000000000000000000079a02482a880bce3f13e09da970dc34db4cd24d10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ce2111f9ab8909b71ebadc9b6458daefe069eda4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000".to_string(),
     * signature:  "0x000012cea6000000967a7600ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".to_string(),
     * call_gas_limit: "0xabb8".to_string(),
     * verification_gas_limit: "0xfa07".to_string(),
     * pre_verification_gas: "0x8e4d78".to_string(),
     * max_fee_per_gas: "0x1af6f".to_string(),
     * max_priority_fee_per_gas: "0x1adb0".to_string(),
     * paymaster: Some("0xEF725Aa22d43Ea69FB22bE2EBe6ECa205a6BCf5B".to_string()),
     * paymaster_verification_gas_limit: "0x7415".to_string(),
     * paymaster_post_op_gas_limit: "0x".to_string(),
     * paymaster_data: Some("000000000000000067789a97c4af0f8ae7acc9237c8f9611a0eb4662009d366b8defdf5f68fed25d22ca77be64b8eef49d917c3f8642ca539571594a84be9d0ee717c099160b79a845bea2111b".to_string()),
     * factory: None,
     * factory_data: None,
     * };
     *
     * let signature = safe.sign_4337_op(480, &user_op).unwrap();
     *
     * println!("Signature: {}", signature.to_hex_string());
     * ```
     */
open func sign4337Op(chainId: UInt32, userOperation: UserOperation)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_4337_op(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypeUserOperation_lower(userOperation),$0
    )
})
}
    
    /**
     * Signs a `Permit2` transfer on behalf of the Safe Smart Account.
     *
     * Used by Mini Apps where users approve transfers for specific tokens and amounts for a period of time on their behalf.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed.
     * - `transfer`: The `Permit2` transfer to sign.
     *
     * # Errors
     * - Will throw an error if the transfer is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signPermit2Transfer(chainId: UInt32, transfer: Permit2TransferFrom)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_permit2_transfer(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypePermit2TransferFrom_lower(transfer),$0
    )
})
}
    
    /**
     * Signs a transaction on behalf of the Safe Smart Account.
     *
     * This allows execution of normal transactions for the Safe.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the transaction is being signed.
     * - `transaction`: The transaction to sign.
     *
     * # Errors
     * - Will throw an error if the transaction is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signTransaction(chainId: UInt32, transaction: SafeTransaction)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_transaction(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypeSafeTransaction_lower(transaction),$0
    )
})
}
    
    /**
     * Signs an arbitrary EIP-712 typed data message on behalf of the Safe Smart Account.
     *
     * Please note that certain primary types are restricted and cannot be signed. For example Permit2's `PermitTransferFrom` is restricted.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `stringified_typed_data`: A JSON string representing the typed data as per EIP-712.
     *
     * # Errors
     * - Will throw an error if the typed data is not a valid JSON string.
     * - Will throw an error if the typed data is not a valid EIP-712 typed data message.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signTypedData(chainId: UInt32, stringifiedTypedData: String)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_typed_data(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterString.lower(stringifiedTypedData),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeSmartAccount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SafeSmartAccount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SafeSmartAccount {
        return SafeSmartAccount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SafeSmartAccount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeSmartAccount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SafeSmartAccount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccount_lift(_ pointer: UnsafeMutableRawPointer) throws -> SafeSmartAccount {
    return try FfiConverterTypeSafeSmartAccount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccount_lower(_ value: SafeSmartAccount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSafeSmartAccount.lower(value)
}






/**
 * A simple demo struct to test tooling functionality like log prefixing and error handling.
 */
public protocol ToolingDemoProtocol: AnyObject, Sendable {
    
    /**
     * Demo: Async operation that showcases automatic tokio runtime configuration
     *
     * This async method demonstrates that the bedrock_export macro automatically
     * adds `async_runtime = "tokio"` to the uniffi::export attribute when any
     * async functions are detected in the impl block.
     *
     * # Errors
     *
     * Returns `DemoError::Generic` if the async operation fails.
     */
    func demoAsyncOperation(delayMs: UInt64) async throws  -> String
    
    /**
     * Demo: Strongly typed errors for known, structured error cases
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if username is empty.
     * Returns `DemoError::AuthenticationFailed` if credentials are invalid.
     * Returns `DemoError::NetworkTimeout` if user is "slowuser".
     * Returns `DemoError::Generic` if the generic operation fails.
     */
    func demoAuthenticate(username: String, password: String) throws  -> String
    
    /**
     * Demo: Generic errors for complex operations with anyhow error chains
     *
     * # Errors
     *
     * Returns `DemoError::Generic` for various error conditions including
     * empty input, network errors, parse errors, and deep chain errors.
     */
    func demoGenericOperation(input: String) throws  -> String
    
    /**
     * Demo: Mixed usage - structured errors for validation, generic for complex operations
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if operation is empty or unknown.
     * Returns `DemoError::Generic` if the processing operation fails.
     */
    func demoMixedOperation(operation: String, data: String) throws  -> String
    
    /**
     * Returns a simple result for testing.
     */
    func getDemoResult()  -> String
    
    /**
     * Logs a simple message to test log prefixing.
     */
    func logMessage(message: String) 
    
    /**
     * Logs messages at different levels to test log prefixing.
     */
    func testLogLevels() 
    
}
/**
 * A simple demo struct to test tooling functionality like log prefixing and error handling.
 */
open class ToolingDemo: ToolingDemoProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_toolingdemo(self.pointer, $0) }
    }
    /**
     * Creates a new tooling demo instance.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_toolingdemo_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_toolingdemo(pointer, $0) }
    }

    

    
    /**
     * Demo: Async operation that showcases automatic tokio runtime configuration
     *
     * This async method demonstrates that the bedrock_export macro automatically
     * adds `async_runtime = "tokio"` to the uniffi::export attribute when any
     * async functions are detected in the impl block.
     *
     * # Errors
     *
     * Returns `DemoError::Generic` if the async operation fails.
     */
open func demoAsyncOperation(delayMs: UInt64)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_toolingdemo_demo_async_operation(
                    self.uniffiClonePointer(),
                    FfiConverterUInt64.lower(delayMs)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_rust_buffer,
            completeFunc: ffi_bedrock_rust_future_complete_rust_buffer,
            freeFunc: ffi_bedrock_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDemoError_lift
        )
}
    
    /**
     * Demo: Strongly typed errors for known, structured error cases
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if username is empty.
     * Returns `DemoError::AuthenticationFailed` if credentials are invalid.
     * Returns `DemoError::NetworkTimeout` if user is "slowuser".
     * Returns `DemoError::Generic` if the generic operation fails.
     */
open func demoAuthenticate(username: String, password: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_authenticate(self.uniffiClonePointer(),
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),$0
    )
})
}
    
    /**
     * Demo: Generic errors for complex operations with anyhow error chains
     *
     * # Errors
     *
     * Returns `DemoError::Generic` for various error conditions including
     * empty input, network errors, parse errors, and deep chain errors.
     */
open func demoGenericOperation(input: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_generic_operation(self.uniffiClonePointer(),
        FfiConverterString.lower(input),$0
    )
})
}
    
    /**
     * Demo: Mixed usage - structured errors for validation, generic for complex operations
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if operation is empty or unknown.
     * Returns `DemoError::Generic` if the processing operation fails.
     */
open func demoMixedOperation(operation: String, data: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_mixed_operation(self.uniffiClonePointer(),
        FfiConverterString.lower(operation),
        FfiConverterString.lower(data),$0
    )
})
}
    
    /**
     * Returns a simple result for testing.
     */
open func getDemoResult() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_get_demo_result(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Logs a simple message to test log prefixing.
     */
open func logMessage(message: String)  {try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_log_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
}
}
    
    /**
     * Logs messages at different levels to test log prefixing.
     */
open func testLogLevels()  {try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_test_log_levels(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeToolingDemo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ToolingDemo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ToolingDemo {
        return ToolingDemo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ToolingDemo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ToolingDemo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ToolingDemo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToolingDemo_lift(_ pointer: UnsafeMutableRawPointer) throws -> ToolingDemo {
    return try FfiConverterTypeToolingDemo.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToolingDemo_lower(_ value: ToolingDemo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeToolingDemo.lower(value)
}




/**
 * For Swift & Kotlin usage only.
 *
 * The token and amount details for a transfer signed in the permit transfer signature.
 *
 * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/interfaces/ISignatureTransfer.sol#L22>
 */
public struct Permit2TokenPermissions {
    /**
     * ERC-20 token address
     * Solidity type: `address`
     */
    public var token: String
    /**
     * The maximum amount of tokens that can be transferred
     * Solidity type: `uint256`
     */
    public var amount: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * ERC-20 token address
         * Solidity type: `address`
         */token: String, 
        /**
         * The maximum amount of tokens that can be transferred
         * Solidity type: `uint256`
         */amount: String) {
        self.token = token
        self.amount = amount
    }
}

#if compiler(>=6)
extension Permit2TokenPermissions: Sendable {}
#endif


extension Permit2TokenPermissions: Equatable, Hashable {
    public static func ==(lhs: Permit2TokenPermissions, rhs: Permit2TokenPermissions) -> Bool {
        if lhs.token != rhs.token {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(token)
        hasher.combine(amount)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermit2TokenPermissions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Permit2TokenPermissions {
        return
            try Permit2TokenPermissions(
                token: FfiConverterString.read(from: &buf), 
                amount: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Permit2TokenPermissions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.token, into: &buf)
        FfiConverterString.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermit2TokenPermissions_lift(_ buf: RustBuffer) throws -> Permit2TokenPermissions {
    return try FfiConverterTypePermit2TokenPermissions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermit2TokenPermissions_lower(_ value: Permit2TokenPermissions) -> RustBuffer {
    return FfiConverterTypePermit2TokenPermissions.lower(value)
}


/**
 * For Swift & Kotlin usage only.
 *
 * Allows foreign code to construct a signed permit message for a single token transfer.
 *
 * [Permit2](https://docs.uniswap.org/contracts/permit2/overview) is an extension to EIP-2612 that allows for more efficient token approvals.
 *
 * In World App, Permit2 is used to approve tokens for a Mini App spender to transfer on behalf of the user.
 *
 * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/interfaces/ISignatureTransfer.sol#L30>
 */
public struct Permit2TransferFrom {
    /**
     * The token and amount allowed for transfers.
     */
    public var permitted: Permit2TokenPermissions
    /**
     * The address of the spender
     * Solidity type: `address`
     */
    public var spender: String
    /**
     * A unique value for every token owner's signature to prevent signature replays
     * Solidity type: `uint256`
     */
    public var nonce: String
    /**
     * The expiration timestamp on the permit signature
     * Solidity type: `uint256`
     */
    public var deadline: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The token and amount allowed for transfers.
         */permitted: Permit2TokenPermissions, 
        /**
         * The address of the spender
         * Solidity type: `address`
         */spender: String, 
        /**
         * A unique value for every token owner's signature to prevent signature replays
         * Solidity type: `uint256`
         */nonce: String, 
        /**
         * The expiration timestamp on the permit signature
         * Solidity type: `uint256`
         */deadline: String) {
        self.permitted = permitted
        self.spender = spender
        self.nonce = nonce
        self.deadline = deadline
    }
}

#if compiler(>=6)
extension Permit2TransferFrom: Sendable {}
#endif


extension Permit2TransferFrom: Equatable, Hashable {
    public static func ==(lhs: Permit2TransferFrom, rhs: Permit2TransferFrom) -> Bool {
        if lhs.permitted != rhs.permitted {
            return false
        }
        if lhs.spender != rhs.spender {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.deadline != rhs.deadline {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(permitted)
        hasher.combine(spender)
        hasher.combine(nonce)
        hasher.combine(deadline)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePermit2TransferFrom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Permit2TransferFrom {
        return
            try Permit2TransferFrom(
                permitted: FfiConverterTypePermit2TokenPermissions.read(from: &buf), 
                spender: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf), 
                deadline: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Permit2TransferFrom, into buf: inout [UInt8]) {
        FfiConverterTypePermit2TokenPermissions.write(value.permitted, into: &buf)
        FfiConverterString.write(value.spender, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
        FfiConverterString.write(value.deadline, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermit2TransferFrom_lift(_ buf: RustBuffer) throws -> Permit2TransferFrom {
    return try FfiConverterTypePermit2TransferFrom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePermit2TransferFrom_lower(_ value: Permit2TransferFrom) -> RustBuffer {
    return FfiConverterTypePermit2TransferFrom.lower(value)
}


/**
 * For Swift & Kotlin usage only.
 *
 * Represents a Safe Smart Account transaction which can be initialized by foreign code to be then signed.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account/blob/v1.4.1/contracts/Safe.sol#L139>
 */
public struct SafeTransaction {
    /**
     * Destination address of the Safe transaction.
     * Solidity type: `address`
     */
    public var to: String
    /**
     * Ether value of the Safe transaction.
     * Solidity type: `uint256`
     */
    public var value: String
    /**
     * Data payload of the Safe transaction.
     * Solidity type: `bytes`
     */
    public var data: String
    /**
     * The type of operation to perform on behalf of the Safe Smart Account.
     * Solidity type: `uint8`
     */
    public var operation: SafeOperation
    /**
     * The maximum gas that can be used for the Safe transaction.
     * Solidity type: `uint256`
     */
    public var safeTxGas: String
    /**
     * Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)
     * Solidity type: `uint256`
     */
    public var baseGas: String
    /**
     * Gas price that should be used for the payment calculation.
     * Solidity type: `uint256`
     */
    public var gasPrice: String
    /**
     * Token address (or 0 if ETH) that is used for the payment.
     * Solidity type: `address`
     */
    public var gasToken: String
    /**
     * Address of receiver of gas payment (or 0 if tx.origin).
     * Solidity type: `address`
     */
    public var refundReceiver: String
    /**
     * The sequential nonce of the transaction. Used to prevent replay attacks.
     * Solidity type: `uint256`
     */
    public var nonce: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Destination address of the Safe transaction.
         * Solidity type: `address`
         */to: String, 
        /**
         * Ether value of the Safe transaction.
         * Solidity type: `uint256`
         */value: String, 
        /**
         * Data payload of the Safe transaction.
         * Solidity type: `bytes`
         */data: String, 
        /**
         * The type of operation to perform on behalf of the Safe Smart Account.
         * Solidity type: `uint8`
         */operation: SafeOperation, 
        /**
         * The maximum gas that can be used for the Safe transaction.
         * Solidity type: `uint256`
         */safeTxGas: String, 
        /**
         * Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)
         * Solidity type: `uint256`
         */baseGas: String, 
        /**
         * Gas price that should be used for the payment calculation.
         * Solidity type: `uint256`
         */gasPrice: String, 
        /**
         * Token address (or 0 if ETH) that is used for the payment.
         * Solidity type: `address`
         */gasToken: String, 
        /**
         * Address of receiver of gas payment (or 0 if tx.origin).
         * Solidity type: `address`
         */refundReceiver: String, 
        /**
         * The sequential nonce of the transaction. Used to prevent replay attacks.
         * Solidity type: `uint256`
         */nonce: String) {
        self.to = to
        self.value = value
        self.data = data
        self.operation = operation
        self.safeTxGas = safeTxGas
        self.baseGas = baseGas
        self.gasPrice = gasPrice
        self.gasToken = gasToken
        self.refundReceiver = refundReceiver
        self.nonce = nonce
    }
}

#if compiler(>=6)
extension SafeTransaction: Sendable {}
#endif


extension SafeTransaction: Equatable, Hashable {
    public static func ==(lhs: SafeTransaction, rhs: SafeTransaction) -> Bool {
        if lhs.to != rhs.to {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.operation != rhs.operation {
            return false
        }
        if lhs.safeTxGas != rhs.safeTxGas {
            return false
        }
        if lhs.baseGas != rhs.baseGas {
            return false
        }
        if lhs.gasPrice != rhs.gasPrice {
            return false
        }
        if lhs.gasToken != rhs.gasToken {
            return false
        }
        if lhs.refundReceiver != rhs.refundReceiver {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(to)
        hasher.combine(value)
        hasher.combine(data)
        hasher.combine(operation)
        hasher.combine(safeTxGas)
        hasher.combine(baseGas)
        hasher.combine(gasPrice)
        hasher.combine(gasToken)
        hasher.combine(refundReceiver)
        hasher.combine(nonce)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeTransaction {
        return
            try SafeTransaction(
                to: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                data: FfiConverterString.read(from: &buf), 
                operation: FfiConverterTypeSafeOperation.read(from: &buf), 
                safeTxGas: FfiConverterString.read(from: &buf), 
                baseGas: FfiConverterString.read(from: &buf), 
                gasPrice: FfiConverterString.read(from: &buf), 
                gasToken: FfiConverterString.read(from: &buf), 
                refundReceiver: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SafeTransaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.to, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterString.write(value.data, into: &buf)
        FfiConverterTypeSafeOperation.write(value.operation, into: &buf)
        FfiConverterString.write(value.safeTxGas, into: &buf)
        FfiConverterString.write(value.baseGas, into: &buf)
        FfiConverterString.write(value.gasPrice, into: &buf)
        FfiConverterString.write(value.gasToken, into: &buf)
        FfiConverterString.write(value.refundReceiver, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeTransaction_lift(_ buf: RustBuffer) throws -> SafeTransaction {
    return try FfiConverterTypeSafeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeTransaction_lower(_ value: SafeTransaction) -> RustBuffer {
    return FfiConverterTypeSafeTransaction.lower(value)
}


/**
 * A pseudo-transaction object for EIP-4337. Used to execute transactions through the Safe Smart Account.
 *
 * This object is expected to be initialized from foreign languages.
 *
 * Reference: <https://www.erc4337.io/docs/understanding-ERC-4337/user-operation>
 *
 * Note the types of this struct are types that can be lifted from foreign languages to be then parsed and validated.
 */
public struct UserOperation {
    /**
     * The address of the smart contract account (Solidity type: `address`)
     */
    public var sender: String
    /**
     * Anti-replay protection; also used as the salt for first-time account creation (Solidity type: `uint256`)
     */
    public var nonce: String
    /**
     * Data that's passed to the sender for execution (Solidity type: `bytes`)
     */
    public var callData: String
    /**
     * Gas limit for execution phase (Solidity type: `uint128`)
     */
    public var callGasLimit: String
    /**
     * Gas limit for verification phase (Solidity type: `uint128`)
     */
    public var verificationGasLimit: String
    /**
     * Gas to compensate the bundler (Solidity type: `uint256`)
     */
    public var preVerificationGas: String
    /**
     * Maximum fee per gas (similar to [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)'s `max_fee_per_gas`) (Solidity type: `uint256`)
     */
    public var maxFeePerGas: String
    /**
     * Maximum priority fee per gas (Solidity type: `uint128`)
     */
    public var maxPriorityFeePerGas: String
    /**
     * Paymaster contact address (Solidity type: `address`)
     */
    public var paymaster: String?
    /**
     * Paymaster verification gas limit (Solidity type: `uint128`)
     */
    public var paymasterVerificationGasLimit: String
    /**
     * Paymaster post-operation gas limit (Solidity type: `uint128`)
     */
    public var paymasterPostOpGasLimit: String
    /**
     * Paymaster additional data for verification (Solidity type: `bytes`)
     */
    public var paymasterData: String?
    /**
     * Used to validate a `UserOperation` along with the nonce during verification (Solidity type: `bytes`)
     */
    public var signature: String
    /**
     * Factory address (Solidity type: `address`)
     */
    public var factory: String?
    /**
     * Factory data (Solidity type: `bytes`)
     */
    public var factoryData: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The address of the smart contract account (Solidity type: `address`)
         */sender: String, 
        /**
         * Anti-replay protection; also used as the salt for first-time account creation (Solidity type: `uint256`)
         */nonce: String, 
        /**
         * Data that's passed to the sender for execution (Solidity type: `bytes`)
         */callData: String, 
        /**
         * Gas limit for execution phase (Solidity type: `uint128`)
         */callGasLimit: String, 
        /**
         * Gas limit for verification phase (Solidity type: `uint128`)
         */verificationGasLimit: String, 
        /**
         * Gas to compensate the bundler (Solidity type: `uint256`)
         */preVerificationGas: String, 
        /**
         * Maximum fee per gas (similar to [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)'s `max_fee_per_gas`) (Solidity type: `uint256`)
         */maxFeePerGas: String, 
        /**
         * Maximum priority fee per gas (Solidity type: `uint128`)
         */maxPriorityFeePerGas: String, 
        /**
         * Paymaster contact address (Solidity type: `address`)
         */paymaster: String?, 
        /**
         * Paymaster verification gas limit (Solidity type: `uint128`)
         */paymasterVerificationGasLimit: String, 
        /**
         * Paymaster post-operation gas limit (Solidity type: `uint128`)
         */paymasterPostOpGasLimit: String, 
        /**
         * Paymaster additional data for verification (Solidity type: `bytes`)
         */paymasterData: String?, 
        /**
         * Used to validate a `UserOperation` along with the nonce during verification (Solidity type: `bytes`)
         */signature: String, 
        /**
         * Factory address (Solidity type: `address`)
         */factory: String?, 
        /**
         * Factory data (Solidity type: `bytes`)
         */factoryData: String?) {
        self.sender = sender
        self.nonce = nonce
        self.callData = callData
        self.callGasLimit = callGasLimit
        self.verificationGasLimit = verificationGasLimit
        self.preVerificationGas = preVerificationGas
        self.maxFeePerGas = maxFeePerGas
        self.maxPriorityFeePerGas = maxPriorityFeePerGas
        self.paymaster = paymaster
        self.paymasterVerificationGasLimit = paymasterVerificationGasLimit
        self.paymasterPostOpGasLimit = paymasterPostOpGasLimit
        self.paymasterData = paymasterData
        self.signature = signature
        self.factory = factory
        self.factoryData = factoryData
    }
}

#if compiler(>=6)
extension UserOperation: Sendable {}
#endif


extension UserOperation: Equatable, Hashable {
    public static func ==(lhs: UserOperation, rhs: UserOperation) -> Bool {
        if lhs.sender != rhs.sender {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.callData != rhs.callData {
            return false
        }
        if lhs.callGasLimit != rhs.callGasLimit {
            return false
        }
        if lhs.verificationGasLimit != rhs.verificationGasLimit {
            return false
        }
        if lhs.preVerificationGas != rhs.preVerificationGas {
            return false
        }
        if lhs.maxFeePerGas != rhs.maxFeePerGas {
            return false
        }
        if lhs.maxPriorityFeePerGas != rhs.maxPriorityFeePerGas {
            return false
        }
        if lhs.paymaster != rhs.paymaster {
            return false
        }
        if lhs.paymasterVerificationGasLimit != rhs.paymasterVerificationGasLimit {
            return false
        }
        if lhs.paymasterPostOpGasLimit != rhs.paymasterPostOpGasLimit {
            return false
        }
        if lhs.paymasterData != rhs.paymasterData {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.factory != rhs.factory {
            return false
        }
        if lhs.factoryData != rhs.factoryData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sender)
        hasher.combine(nonce)
        hasher.combine(callData)
        hasher.combine(callGasLimit)
        hasher.combine(verificationGasLimit)
        hasher.combine(preVerificationGas)
        hasher.combine(maxFeePerGas)
        hasher.combine(maxPriorityFeePerGas)
        hasher.combine(paymaster)
        hasher.combine(paymasterVerificationGasLimit)
        hasher.combine(paymasterPostOpGasLimit)
        hasher.combine(paymasterData)
        hasher.combine(signature)
        hasher.combine(factory)
        hasher.combine(factoryData)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserOperation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserOperation {
        return
            try UserOperation(
                sender: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf), 
                callData: FfiConverterString.read(from: &buf), 
                callGasLimit: FfiConverterString.read(from: &buf), 
                verificationGasLimit: FfiConverterString.read(from: &buf), 
                preVerificationGas: FfiConverterString.read(from: &buf), 
                maxFeePerGas: FfiConverterString.read(from: &buf), 
                maxPriorityFeePerGas: FfiConverterString.read(from: &buf), 
                paymaster: FfiConverterOptionString.read(from: &buf), 
                paymasterVerificationGasLimit: FfiConverterString.read(from: &buf), 
                paymasterPostOpGasLimit: FfiConverterString.read(from: &buf), 
                paymasterData: FfiConverterOptionString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf), 
                factory: FfiConverterOptionString.read(from: &buf), 
                factoryData: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserOperation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sender, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
        FfiConverterString.write(value.callData, into: &buf)
        FfiConverterString.write(value.callGasLimit, into: &buf)
        FfiConverterString.write(value.verificationGasLimit, into: &buf)
        FfiConverterString.write(value.preVerificationGas, into: &buf)
        FfiConverterString.write(value.maxFeePerGas, into: &buf)
        FfiConverterString.write(value.maxPriorityFeePerGas, into: &buf)
        FfiConverterOptionString.write(value.paymaster, into: &buf)
        FfiConverterString.write(value.paymasterVerificationGasLimit, into: &buf)
        FfiConverterString.write(value.paymasterPostOpGasLimit, into: &buf)
        FfiConverterOptionString.write(value.paymasterData, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
        FfiConverterOptionString.write(value.factory, into: &buf)
        FfiConverterOptionString.write(value.factoryData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserOperation_lift(_ buf: RustBuffer) throws -> UserOperation {
    return try FfiConverterTypeUserOperation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserOperation_lower(_ value: UserOperation) -> RustBuffer {
    return FfiConverterTypeUserOperation.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the environment for Bedrock operations
 */

public enum BedrockEnvironment {
    
    /**
     * Staging environment
     */
    case staging
    /**
     * Production environment
     */
    case production
}


#if compiler(>=6)
extension BedrockEnvironment: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBedrockEnvironment: FfiConverterRustBuffer {
    typealias SwiftType = BedrockEnvironment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BedrockEnvironment {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .staging
        
        case 2: return .production
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BedrockEnvironment, into buf: inout [UInt8]) {
        switch value {
        
        
        case .staging:
            writeInt(&buf, Int32(1))
        
        
        case .production:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockEnvironment_lift(_ buf: RustBuffer) throws -> BedrockEnvironment {
    return try FfiConverterTypeBedrockEnvironment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockEnvironment_lower(_ value: BedrockEnvironment) -> RustBuffer {
    return FfiConverterTypeBedrockEnvironment.lower(value)
}


extension BedrockEnvironment: Equatable, Hashable {}







/**
 * Error type for demonstrating bedrock error handling patterns.
 *
 * The `#[bedrock_error]` macro automatically:
 * - Adds `#[derive(Debug, thiserror::Error, uniffi::Error)]` and `#[uniffi(flat_error)]`
 * - Adds a `Generic { message: String }` variant
 * - Implements `From<anyhow::Error>` for automatic conversion
 * - Provides helper methods for error handling
 */
public enum DemoError: Swift.Error {

    
    
    /**
     * Authentication failed with a specific error code
     */
    case AuthenticationFailed(message: String)
    
    /**
     * Network operation timed out after specified number of seconds
     */
    case NetworkTimeout(message: String)
    
    /**
     * Invalid input was provided with a descriptive message
     */
    case InvalidInput(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDemoError: FfiConverterRustBuffer {
    typealias SwiftType = DemoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DemoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AuthenticationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NetworkTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DemoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AuthenticationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .NetworkTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDemoError_lift(_ buf: RustBuffer) throws -> DemoError {
    return try FfiConverterTypeDemoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDemoError_lower(_ value: DemoError) -> RustBuffer {
    return FfiConverterTypeDemoError.lower(value)
}


extension DemoError: Equatable, Hashable {}




extension DemoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enumeration of possible log levels.
 *
 * This enum represents the severity levels that can be used when logging messages.
 */

public enum LogLevel {
    
    /**
     * Designates very low priority, often extremely detailed messages.
     */
    case trace
    /**
     * Designates lower priority debugging information.
     */
    case debug
    /**
     * Designates informational messages that highlight the progress of the application.
     */
    case info
    /**
     * Designates potentially harmful situations.
     */
    case warn
    /**
     * Designates error events that might still allow the application to continue running.
     */
    case error
}


#if compiler(>=6)
extension LogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .trace
        
        case 2: return .debug
        
        case 3: return .info
        
        case 4: return .warn
        
        case 5: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .trace:
            writeInt(&buf, Int32(1))
        
        
        case .debug:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .warn:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}







/**
 * Represents primitive errors on Bedrock. These errors may not be called **from** FFI.
 */
public enum PrimitiveError: Swift.Error {

    
    
    /**
     * The provided string is not validly encoded hex data.
     */
    case InvalidHexString(message: String)
    
    /**
     * A provided raw input could not be parsed, is incorrectly formatted, incorrectly encoded or otherwise invalid.
     */
    case InvalidInput(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimitiveError: FfiConverterRustBuffer {
    typealias SwiftType = PrimitiveError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimitiveError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHexString(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PrimitiveError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidHexString(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitiveError_lift(_ buf: RustBuffer) throws -> PrimitiveError {
    return try FfiConverterTypePrimitiveError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitiveError_lower(_ value: PrimitiveError) -> RustBuffer {
    return FfiConverterTypePrimitiveError.lower(value)
}


extension PrimitiveError: Equatable, Hashable {}




extension PrimitiveError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of operation to perform on behalf of the Safe Smart Account.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account/blob/v1.4.1/contracts/libraries/Enum.sol#L9>
 */

public enum SafeOperation : UInt8 {
    
    /**
     * Performs a standard message call.
     */
    case call = 0
    /**
     * Performs a `delegatecall`. Executes the target contract’s code in the context of the Safe's storage.
     */
    case delegateCall = 1
}


#if compiler(>=6)
extension SafeOperation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeOperation: FfiConverterRustBuffer {
    typealias SwiftType = SafeOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .call
        
        case 2: return .delegateCall
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SafeOperation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .call:
            writeInt(&buf, Int32(1))
        
        
        case .delegateCall:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeOperation_lift(_ buf: RustBuffer) throws -> SafeOperation {
    return try FfiConverterTypeSafeOperation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeOperation_lower(_ value: SafeOperation) -> RustBuffer {
    return FfiConverterTypeSafeOperation.lower(value)
}


extension SafeOperation: Equatable, Hashable {}







/**
 * Errors that can occur when working with Safe Smart Accounts.
 */
public enum SafeSmartAccountError: Swift.Error {

    
    
    /**
     * Failed to decode a hex-encoded secret key into a k256 signer.
     */
    case KeyDecoding(message: String)
    
    /**
     * Error occurred during the signing process.
     */
    case Signing(message: String)
    
    /**
     * Failed to parse an Ethereum address string.
     */
    case AddressParsing(message: String)
    
    /**
     * Failed to encode data to a specific format.
     */
    case Encoding(message: String)
    
    /**
     * For security reasons, the contract is restricted from directly signing `TypedData`.
     */
    case RestrictedContract(message: String)
    
    /**
     * A provided raw input could not be parsed, is incorrectly formatted, incorrectly encoded or otherwise invalid.
     */
    case InvalidInput(message: String)
    
    /**
     * An error occurred with a primitive type. See `PrimitiveError` for more details.
     */
    case PrimitiveError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeSmartAccountError: FfiConverterRustBuffer {
    typealias SwiftType = SafeSmartAccountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeSmartAccountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyDecoding(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Signing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .AddressParsing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Encoding(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .RestrictedContract(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .PrimitiveError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SafeSmartAccountError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .KeyDecoding(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Signing(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .AddressParsing(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Encoding(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .RestrictedContract(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .PrimitiveError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccountError_lift(_ buf: RustBuffer) throws -> SafeSmartAccountError {
    return try FfiConverterTypeSafeSmartAccountError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccountError_lower(_ value: SafeSmartAccountError) -> RustBuffer {
    return FfiConverterTypeSafeSmartAccountError.lower(value)
}


extension SafeSmartAccountError: Equatable, Hashable {}




extension SafeSmartAccountError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBedrockConfig: FfiConverterRustBuffer {
    typealias SwiftType = BedrockConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBedrockConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBedrockConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureBedrockInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
/**
 * Gets a reference to the global Bedrock configuration.
 *
 * # Returns
 * An Option containing a reference to the config if initialized, None otherwise.
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * if let config = getConfig() {
 * print("Environment: \(config.environment())")
 * }
 * ```
 */
public func getConfig() -> BedrockConfig?  {
    return try!  FfiConverterOptionTypeBedrockConfig.lift(try! rustCall() {
    uniffi_bedrock_fn_func_get_config($0
    )
})
}
/**
 * Checks if the Bedrock configuration has been initialized.
 *
 * # Returns
 * true if the config has been initialized, false otherwise.
 */
public func isInitialized() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_is_initialized($0
    )
})
}
/**
 * Initializes the global Bedrock configuration.
 *
 * This function should be called once at application startup before any other Bedrock operations.
 * Subsequent calls will be ignored and print a warning.
 *
 * # Arguments
 * * `environment` - The environment to use for all Bedrock operations
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * import Bedrock
 *
 * // In your app delegate or during app initialization
 * setConfig(environment: .staging)
 * ```
 */
public func setConfig(environment: BedrockEnvironment)  {try! rustCall() {
    uniffi_bedrock_fn_func_set_config(
        FfiConverterTypeBedrockEnvironment_lower(environment),$0
    )
}
}
/**
 * Sets the global logger.
 *
 * This function allows you to provide your own implementation of the `Logger` trait.
 * It initializes the logging system and should be called before any logging occurs.
 *
 * # Arguments
 *
 * * `logger` - An `Arc` containing your logger implementation.
 *
 * # Panics
 *
 * Panics if the logger has already been set.
 *
 * # Note
 *
 * If the logger has already been set, this function will print a message and do nothing.
 */
public func setLogger(logger: Logger)  {try! rustCall() {
    uniffi_bedrock_fn_func_set_logger(
        FfiConverterTypeLogger_lower(logger),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bedrock_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bedrock_checksum_func_get_config() != 37061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_is_initialized() != 58806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_config() != 25999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_logger() != 47849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_bedrockconfig_environment() != 53973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_hexencodeddata_to_hex_string() != 53475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_hexencodeddata_to_vec() != 19048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_logger_log() != 30465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_personal_sign() != 21352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_4337_op() != 26789) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_permit2_transfer() != 46178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_transaction() != 18163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_typed_data() != 43822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_async_operation() != 30263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_authenticate() != 11263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_generic_operation() != 47303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_mixed_operation() != 58510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_get_demo_result() != 19522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_log_message() != 550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_test_log_levels() != 43380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_bedrockconfig_new() != 62067) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_hexencodeddata_new() != 40879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_safesmartaccount_new() != 38977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_toolingdemo_new() != 46711) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureBedrockInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all