// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(bedrockFFI)
import bedrockFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bedrock_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bedrock_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureBedrockInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Authenticated HTTP client interface that native applications must implement for bedrock to make backend requests.
 *
 * This trait allows bedrock to make HTTP requests through the native app's networking stack,
 * ensuring proper handling of platform-specific networking requirements like SSL pinning,
 * proxy support, and authentication.
 *
 * Native implementations should map platform-specific errors to the appropriate `HttpError` variants
 * for consistent error handling across platforms.
 */
public protocol AuthenticatedHttpClient: AnyObject, Sendable {
    
    /**
     * Fetches data from the specified URL using the app's backend networking infrastructure.
     *
     * This method should handle all networking concerns including:
     * - SSL certificate validation and pinning
     * - Proxy configuration
     * - Request authentication headers
     * - Timeout handling
     * - Network error handling
     *
     * # Arguments
     * * `url` - The URL to fetch data from
     * * `method` - The HTTP method to use for the request
     * * `headers` - Additional headers to include in the request
     * * `body` - Optional request body data for POST requests
     *
     * # Returns
     * * `Result<Vec<u8>, HttpError>` - The response body as bytes on success, or an error
     *
     * # Errors
     * * `HttpError::BadStatusCode` - For HTTP error status codes (4xx, 5xx) with response body
     * * `HttpError::NoConnectivity` - When no internet connection is available
     * * `HttpError::Timeout` - When the request times out
     * * `HttpError::DnsResolutionFailed` - When DNS lookup fails
     * * `HttpError::ConnectionRefused` - When the server refuses the connection
     * * `HttpError::SslError` - When SSL/TLS validation fails
     * * `HttpError::Cancelled` - When the request is cancelled
     * * `HttpError::Generic` - For other unexpected errors
     */
    func fetchFromAppBackend(url: String, method: HttpMethod, headers: [HttpHeader], body: Data?) async throws  -> Data
    
}
/**
 * Authenticated HTTP client interface that native applications must implement for bedrock to make backend requests.
 *
 * This trait allows bedrock to make HTTP requests through the native app's networking stack,
 * ensuring proper handling of platform-specific networking requirements like SSL pinning,
 * proxy support, and authentication.
 *
 * Native implementations should map platform-specific errors to the appropriate `HttpError` variants
 * for consistent error handling across platforms.
 */
open class AuthenticatedHttpClientImpl: AuthenticatedHttpClient, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_authenticatedhttpclient(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_authenticatedhttpclient(pointer, $0) }
    }

    

    
    /**
     * Fetches data from the specified URL using the app's backend networking infrastructure.
     *
     * This method should handle all networking concerns including:
     * - SSL certificate validation and pinning
     * - Proxy configuration
     * - Request authentication headers
     * - Timeout handling
     * - Network error handling
     *
     * # Arguments
     * * `url` - The URL to fetch data from
     * * `method` - The HTTP method to use for the request
     * * `headers` - Additional headers to include in the request
     * * `body` - Optional request body data for POST requests
     *
     * # Returns
     * * `Result<Vec<u8>, HttpError>` - The response body as bytes on success, or an error
     *
     * # Errors
     * * `HttpError::BadStatusCode` - For HTTP error status codes (4xx, 5xx) with response body
     * * `HttpError::NoConnectivity` - When no internet connection is available
     * * `HttpError::Timeout` - When the request times out
     * * `HttpError::DnsResolutionFailed` - When DNS lookup fails
     * * `HttpError::ConnectionRefused` - When the server refuses the connection
     * * `HttpError::SslError` - When SSL/TLS validation fails
     * * `HttpError::Cancelled` - When the request is cancelled
     * * `HttpError::Generic` - For other unexpected errors
     */
open func fetchFromAppBackend(url: String, method: HttpMethod, headers: [HttpHeader], body: Data?)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_authenticatedhttpclient_fetch_from_app_backend(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(url),FfiConverterTypeHttpMethod_lower(method),FfiConverterSequenceTypeHttpHeader.lower(headers),FfiConverterOptionData.lower(body)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_rust_buffer,
            completeFunc: ffi_bedrock_rust_future_complete_rust_buffer,
            freeFunc: ffi_bedrock_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeHttpError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAuthenticatedHttpClient {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAuthenticatedHttpClient] = [UniffiVTableCallbackInterfaceAuthenticatedHttpClient(
        fetchFromAppBackend: { (
            uniffiHandle: UInt64,
            url: RustBuffer,
            method: RustBuffer,
            headers: RustBuffer,
            body: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeAuthenticatedHttpClient.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.fetchFromAppBackend(
                     url: try FfiConverterString.lift(url),
                     method: try FfiConverterTypeHttpMethod_lift(method),
                     headers: try FfiConverterSequenceTypeHttpHeader.lift(headers),
                     body: try FfiConverterOptionData.lift(body)
                )
            }

            let uniffiHandleSuccess = { (returnValue: Data) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterData.lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeAuthenticatedHttpClient.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface AuthenticatedHttpClient: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitAuthenticatedHttpClient() {
    uniffi_bedrock_fn_init_callback_vtable_authenticatedhttpclient(UniffiCallbackInterfaceAuthenticatedHttpClient.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthenticatedHttpClient: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<AuthenticatedHttpClient>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AuthenticatedHttpClient

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedHttpClient {
        return AuthenticatedHttpClientImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AuthenticatedHttpClient) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthenticatedHttpClient {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AuthenticatedHttpClient, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticatedHttpClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> AuthenticatedHttpClient {
    return try FfiConverterTypeAuthenticatedHttpClient.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthenticatedHttpClient_lower(_ value: AuthenticatedHttpClient) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAuthenticatedHttpClient.lower(value)
}






/**
 * Tools for storing, retrieving, encrypting and decrypting backup data.
 *
 * Unsealed backups are raw bytes with the `RootKey` and files.
 *
 * Unsealed backups becomes sealed backups when they are encrypted with "a backup keypair".
 * Backup keypair is a keypair that is used to encryp  t the raw backup data and generated
 * during the backup creation.
 *
 * Backup keypair itself is encrypted with "a factor secret" to create "encrypted backup keypair".
 * The factor secret is a key that the end user's device / cloud stores or recovers. For example,
 * the factor secret could be a passkey PRF, or a random key that is stored in the iCloud Keychain,
 * or a key that's stored in Turnkey.
 *
 * "Encrypted backup keypair" is stored alongside the sealed backup data. Both are needed to
 * decrypt the backup.
 *
 * Documentation: <https://docs.toolsforhumanity.com/world-app/backup>
 */
public protocol BackupManagerProtocol: AnyObject, Sendable {
    
    /**
     * Adds new factor by re-encrypting the backup keypair (not the backup itself!)
     * with a new factor secret.
     *
     * * `encrypted_backup_key_with_existing_factor_secret` - is the backup keypair that was
     * encrypted with the existing factor secret. Hex encoded.
     * * `existing_factor_secret` - is an existing factor secret that was used to encrypt the backup keypair. Hex encoded.
     * For example, it could be coming from the passkey PRF, or a random key that's
     * stored in the iCloud keychain or Turnkey.
     * * `new_factor_secret` - is the new factor secret that will be used to encrypt the backup keypair. Hex encoded.
     * For example, if the main factor is PRF, this could be a random key that's
     * stored in the iCloud keychain or Turnkey.
     * * `existing_factor_type` - is the type of factor that was used to encrypt the backup keypair.
     * It should mark what kind of key `existing_factor_secret` is.
     * * `new_factor_type` - is the type of factor that will be used to encrypt the backup keypair.
     * It should mark what kind of key `new_factor_secret` is.
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::DecodeBackupKeypairError` - if the backup keypair is invalid.
     * * `BackupError::DecryptBackupKeypairError` - if the backup keypair cannot be decrypted.
     * * `BackupError::EncryptBackupError` - if the backup keypair cannot be encrypted.
     */
    func addNewFactor(encryptedBackupKeyWithExistingFactorSecret: String, existingFactorSecret: String, newFactorSecret: String, existingFactorType: FactorType, newFactorType: FactorType) throws  -> AddNewFactorResult
    
    /**
     * Creates a sealed backup with metadata for a new user with a factor secret. Since it's a new user,
     * the backup won't contain PCP data yet.
     *
     * * `root_secret` - is the root secret seed of the wallet that is used to derive the wallet,
     * World ID identity and PCP encryption keys. Hex encoded for V0 and JSON encoded for V1.
     * * `factor_secret` - is a factor secret that is used to encrypt the backup keypair. Hex encoded.
     * It could be coming from the passkey PRF, or a random key that's stored in the iCloud
     * keychain or Turnkey.
     * * `factor_type` - is the type of factor that was used to encrypt the backup keypair. It should mark what
     * kind of key `factor_secret` is.
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::EncryptBackupError` - if the backup keypair cannot be created or the backup cannot be
     * encrypted.
     */
    func createSealedBackupForNewUser(rootSecret: String, factorSecret: String, factorType: FactorType) throws  -> CreatedBackup
    
    /**
     * Decrypts the sealed backup using the factor secret and the encrypted backup keypair. It then unpacks the backup
     * directly into the file system.
     *
     * * `sealed_backup_data` - is the sealed backup data that was created during sign up. The data is
     * encrypted with the backup keypair public key.
     * * `encrypted_backup_keypair` - is the backup keypair that was encrypted with the factor secret.
     * Hex encoded.
     * * `factor_secret` - is the factor secret that was used to encrypt the backup keypair. Hex encoded.
     * * `factor_type` - is the type of factor that was used to encrypt the backup keypair.
     * It should mark what kind of key `factor_secret` is.
     * * `current_manifest_hash` - hex-encoded 32-byte blake3 hash of the manifest head at the time
     * the fetched backup was created (returned by the remote and provided by the native layer).
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::DecodeBackupKeypairError` - if the encrypted backup keypair is invalid.
     * * `BackupError::DecryptBackupKeypairError` - if the backup keypair cannot be decrypted.
     * * `BackupError::DecryptBackupError` - if the sealed backup cannot be decrypted.
     * * `BackupError::InvalidRootSecretError` - if the root secret in the backup is invalid.
     * * `BackupError::VersionNotDetectedError` - if the backup version cannot be detected.
     * * `BackupError::IoError` - if the backup cannot be read.
     *
     * Decrypts the sealed backup and unpacks it to the file system.
     *
     * # Errors
     * Propagates decoding/decryption errors when inputs are malformed or do not match.
     */
    func decryptAndUnpackSealedBackup(sealedBackupData: Data, encryptedBackupKeypair: String, factorSecret: String, factorType: FactorType, currentManifestHash: String) throws  -> DecryptedBackup
    
    /**
     * Should be called after the backup is disabled/deleted.
     *
     * It processes local state after the backup is disabled/deleted.
     *
     * Currently it:
     * 1. Deletes the local manifest file.
     *
     * # Errors
     * - Returns an error if the post-processing fails.
     */
    func postDeleteBackup() throws 
    
}
/**
 * Tools for storing, retrieving, encrypting and decrypting backup data.
 *
 * Unsealed backups are raw bytes with the `RootKey` and files.
 *
 * Unsealed backups becomes sealed backups when they are encrypted with "a backup keypair".
 * Backup keypair is a keypair that is used to encryp  t the raw backup data and generated
 * during the backup creation.
 *
 * Backup keypair itself is encrypted with "a factor secret" to create "encrypted backup keypair".
 * The factor secret is a key that the end user's device / cloud stores or recovers. For example,
 * the factor secret could be a passkey PRF, or a random key that is stored in the iCloud Keychain,
 * or a key that's stored in Turnkey.
 *
 * "Encrypted backup keypair" is stored alongside the sealed backup data. Both are needed to
 * decrypt the backup.
 *
 * Documentation: <https://docs.toolsforhumanity.com/world-app/backup>
 */
open class BackupManager: BackupManagerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_backupmanager(self.pointer, $0) }
    }
    /**
     * Constructs a new `BackupManager` instance.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_backupmanager_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_backupmanager(pointer, $0) }
    }

    

    
    /**
     * Adds new factor by re-encrypting the backup keypair (not the backup itself!)
     * with a new factor secret.
     *
     * * `encrypted_backup_key_with_existing_factor_secret` - is the backup keypair that was
     * encrypted with the existing factor secret. Hex encoded.
     * * `existing_factor_secret` - is an existing factor secret that was used to encrypt the backup keypair. Hex encoded.
     * For example, it could be coming from the passkey PRF, or a random key that's
     * stored in the iCloud keychain or Turnkey.
     * * `new_factor_secret` - is the new factor secret that will be used to encrypt the backup keypair. Hex encoded.
     * For example, if the main factor is PRF, this could be a random key that's
     * stored in the iCloud keychain or Turnkey.
     * * `existing_factor_type` - is the type of factor that was used to encrypt the backup keypair.
     * It should mark what kind of key `existing_factor_secret` is.
     * * `new_factor_type` - is the type of factor that will be used to encrypt the backup keypair.
     * It should mark what kind of key `new_factor_secret` is.
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::DecodeBackupKeypairError` - if the backup keypair is invalid.
     * * `BackupError::DecryptBackupKeypairError` - if the backup keypair cannot be decrypted.
     * * `BackupError::EncryptBackupError` - if the backup keypair cannot be encrypted.
     */
open func addNewFactor(encryptedBackupKeyWithExistingFactorSecret: String, existingFactorSecret: String, newFactorSecret: String, existingFactorType: FactorType, newFactorType: FactorType)throws  -> AddNewFactorResult  {
    return try  FfiConverterTypeAddNewFactorResult_lift(try rustCallWithError(FfiConverterTypeBackupError_lift) {
    uniffi_bedrock_fn_method_backupmanager_add_new_factor(self.uniffiClonePointer(),
        FfiConverterString.lower(encryptedBackupKeyWithExistingFactorSecret),
        FfiConverterString.lower(existingFactorSecret),
        FfiConverterString.lower(newFactorSecret),
        FfiConverterTypeFactorType_lower(existingFactorType),
        FfiConverterTypeFactorType_lower(newFactorType),$0
    )
})
}
    
    /**
     * Creates a sealed backup with metadata for a new user with a factor secret. Since it's a new user,
     * the backup won't contain PCP data yet.
     *
     * * `root_secret` - is the root secret seed of the wallet that is used to derive the wallet,
     * World ID identity and PCP encryption keys. Hex encoded for V0 and JSON encoded for V1.
     * * `factor_secret` - is a factor secret that is used to encrypt the backup keypair. Hex encoded.
     * It could be coming from the passkey PRF, or a random key that's stored in the iCloud
     * keychain or Turnkey.
     * * `factor_type` - is the type of factor that was used to encrypt the backup keypair. It should mark what
     * kind of key `factor_secret` is.
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::EncryptBackupError` - if the backup keypair cannot be created or the backup cannot be
     * encrypted.
     */
open func createSealedBackupForNewUser(rootSecret: String, factorSecret: String, factorType: FactorType)throws  -> CreatedBackup  {
    return try  FfiConverterTypeCreatedBackup_lift(try rustCallWithError(FfiConverterTypeBackupError_lift) {
    uniffi_bedrock_fn_method_backupmanager_create_sealed_backup_for_new_user(self.uniffiClonePointer(),
        FfiConverterString.lower(rootSecret),
        FfiConverterString.lower(factorSecret),
        FfiConverterTypeFactorType_lower(factorType),$0
    )
})
}
    
    /**
     * Decrypts the sealed backup using the factor secret and the encrypted backup keypair. It then unpacks the backup
     * directly into the file system.
     *
     * * `sealed_backup_data` - is the sealed backup data that was created during sign up. The data is
     * encrypted with the backup keypair public key.
     * * `encrypted_backup_keypair` - is the backup keypair that was encrypted with the factor secret.
     * Hex encoded.
     * * `factor_secret` - is the factor secret that was used to encrypt the backup keypair. Hex encoded.
     * * `factor_type` - is the type of factor that was used to encrypt the backup keypair.
     * It should mark what kind of key `factor_secret` is.
     * * `current_manifest_hash` - hex-encoded 32-byte blake3 hash of the manifest head at the time
     * the fetched backup was created (returned by the remote and provided by the native layer).
     *
     * # Errors
     * * `BackupError::DecodeFactorSecretError` - if the factor secret is invalid, e.g. not hex encoded.
     * * `BackupError::InvalidFactorSecretLengthError` - if the factor secret is not 32 bytes.
     * * `BackupError::DecodeBackupKeypairError` - if the encrypted backup keypair is invalid.
     * * `BackupError::DecryptBackupKeypairError` - if the backup keypair cannot be decrypted.
     * * `BackupError::DecryptBackupError` - if the sealed backup cannot be decrypted.
     * * `BackupError::InvalidRootSecretError` - if the root secret in the backup is invalid.
     * * `BackupError::VersionNotDetectedError` - if the backup version cannot be detected.
     * * `BackupError::IoError` - if the backup cannot be read.
     *
     * Decrypts the sealed backup and unpacks it to the file system.
     *
     * # Errors
     * Propagates decoding/decryption errors when inputs are malformed or do not match.
     */
open func decryptAndUnpackSealedBackup(sealedBackupData: Data, encryptedBackupKeypair: String, factorSecret: String, factorType: FactorType, currentManifestHash: String)throws  -> DecryptedBackup  {
    return try  FfiConverterTypeDecryptedBackup_lift(try rustCallWithError(FfiConverterTypeBackupError_lift) {
    uniffi_bedrock_fn_method_backupmanager_decrypt_and_unpack_sealed_backup(self.uniffiClonePointer(),
        FfiConverterData.lower(sealedBackupData),
        FfiConverterString.lower(encryptedBackupKeypair),
        FfiConverterString.lower(factorSecret),
        FfiConverterTypeFactorType_lower(factorType),
        FfiConverterString.lower(currentManifestHash),$0
    )
})
}
    
    /**
     * Should be called after the backup is disabled/deleted.
     *
     * It processes local state after the backup is disabled/deleted.
     *
     * Currently it:
     * 1. Deletes the local manifest file.
     *
     * # Errors
     * - Returns an error if the post-processing fails.
     */
open func postDeleteBackup()throws   {try rustCallWithError(FfiConverterTypeBackupError_lift) {
    uniffi_bedrock_fn_method_backupmanager_post_delete_backup(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupManager {
        return BackupManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupManager {
    return try FfiConverterTypeBackupManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupManager_lower(_ value: BackupManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupManager.lower(value)
}






/**
 * Foreign trait that native layers implement to perform backup-service network calls.
 *
 * If set, this will be used by Bedrock instead of any internal HTTP client.
 */
public protocol BackupServiceApi: AnyObject, Sendable {
    
    /**
     * Uploads an updated backup using the `/v1/sync` endpoint.
     *
     * Reference: <https://github.com/worldcoin/backup-service/blob/main/src/routes/sync_backup.rs>
     */
    func sync(request: SyncSubmitRequest) async throws 
    
    /**
     * Retrieves metadata (manifest head) using the `/v1/retrieve_metadata` endpoint.
     *
     * Reference: <https://github.com/worldcoin/backup-service/blob/main/src/routes/retrieve_metadata.rs>
     *
     * # Notes
     * This expects specific attributes from the response, not all the response is returned to Bedrock (avoids additional memory allocations)
     */
    func retrieveMetadata() async throws  -> RetrieveMetadataResponsePayload
    
}
/**
 * Foreign trait that native layers implement to perform backup-service network calls.
 *
 * If set, this will be used by Bedrock instead of any internal HTTP client.
 */
open class BackupServiceApiImpl: BackupServiceApi, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_backupserviceapi(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_backupserviceapi(pointer, $0) }
    }

    

    
    /**
     * Uploads an updated backup using the `/v1/sync` endpoint.
     *
     * Reference: <https://github.com/worldcoin/backup-service/blob/main/src/routes/sync_backup.rs>
     */
open func sync(request: SyncSubmitRequest)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_backupserviceapi_sync(
                    self.uniffiClonePointer(),
                    FfiConverterTypeSyncSubmitRequest_lower(request)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_void,
            completeFunc: ffi_bedrock_rust_future_complete_void,
            freeFunc: ffi_bedrock_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHttpError_lift
        )
}
    
    /**
     * Retrieves metadata (manifest head) using the `/v1/retrieve_metadata` endpoint.
     *
     * Reference: <https://github.com/worldcoin/backup-service/blob/main/src/routes/retrieve_metadata.rs>
     *
     * # Notes
     * This expects specific attributes from the response, not all the response is returned to Bedrock (avoids additional memory allocations)
     */
open func retrieveMetadata()async throws  -> RetrieveMetadataResponsePayload  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_backupserviceapi_retrieve_metadata(
                    self.uniffiClonePointer()
                    
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_rust_buffer,
            completeFunc: ffi_bedrock_rust_future_complete_rust_buffer,
            freeFunc: ffi_bedrock_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRetrieveMetadataResponsePayload_lift,
            errorHandler: FfiConverterTypeHttpError_lift
        )
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBackupServiceApi {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceBackupServiceApi] = [UniffiVTableCallbackInterfaceBackupServiceApi(
        sync: { (
            uniffiHandle: UInt64,
            request: RustBuffer,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteVoid,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> () in
                guard let uniffiObj = try? FfiConverterTypeBackupServiceApi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.sync(
                     request: try FfiConverterTypeSyncSubmitRequest_lift(request)
                )
            }

            let uniffiHandleSuccess = { (returnValue: ()) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructVoid(
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        retrieveMetadata: { (
            uniffiHandle: UInt64,
            uniffiFutureCallback: @escaping UniffiForeignFutureCompleteRustBuffer,
            uniffiCallbackData: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<UniffiForeignFuture>
        ) in
            let makeCall = {
                () async throws -> RetrieveMetadataResponsePayload in
                guard let uniffiObj = try? FfiConverterTypeBackupServiceApi.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try await uniffiObj.retrieveMetadata(
                )
            }

            let uniffiHandleSuccess = { (returnValue: RetrieveMetadataResponsePayload) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: FfiConverterTypeRetrieveMetadataResponsePayload_lower(returnValue),
                        callStatus: RustCallStatus()
                    )
                )
            }
            let uniffiHandleError = { (statusCode, errorBuf) in
                uniffiFutureCallback(
                    uniffiCallbackData,
                    UniffiForeignFutureStructRustBuffer(
                        returnValue: RustBuffer.empty(),
                        callStatus: RustCallStatus(code: statusCode, errorBuf: errorBuf)
                    )
                )
            }
            let uniffiForeignFuture = uniffiTraitInterfaceCallAsyncWithError(
                makeCall: makeCall,
                handleSuccess: uniffiHandleSuccess,
                handleError: uniffiHandleError,
                lowerError: FfiConverterTypeHttpError_lower
            )
            uniffiOutReturn.pointee = uniffiForeignFuture
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeBackupServiceApi.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface BackupServiceApi: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitBackupServiceApi() {
    uniffi_bedrock_fn_init_callback_vtable_backupserviceapi(UniffiCallbackInterfaceBackupServiceApi.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupServiceApi: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<BackupServiceApi>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BackupServiceApi

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupServiceApi {
        return BackupServiceApiImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BackupServiceApi) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupServiceApi {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BackupServiceApi, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupServiceApi_lift(_ pointer: UnsafeMutableRawPointer) throws -> BackupServiceApi {
    return try FfiConverterTypeBackupServiceApi.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupServiceApi_lower(_ value: BackupServiceApi) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBackupServiceApi.lower(value)
}






/**
 * A primitive for interacting with Ethereum addresses.
 *
 * Wraps the `Address` type from the `alloy` crate for foreign exports.
 */
public protocol BedrockAddressProtocol: AnyObject, Sendable {
    
    /**
     * Returns the address as an ABI encoded byte array.
     */
    func asAbiEncode()  -> Data
    
    /**
     * Returns the address as an ABI **packed** encoded byte array.
     */
    func asAbiEncodePacked()  -> Data
    
    /**
     * Returns the address as a checksummed string.
     *
     * Reference: <https://eips.ethereum.org/EIPS/eip-55>
     */
    func asChecksummedStr(chainId: UInt64?)  -> String
    
}
/**
 * A primitive for interacting with Ethereum addresses.
 *
 * Wraps the `Address` type from the `alloy` crate for foreign exports.
 */
open class BedrockAddress: BedrockAddressProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_bedrockaddress(self.pointer, $0) }
    }
    /**
     * Initializes a new `BedrockAddress` from a String.
     *
     * # Errors
     * - `PrimitiveError::InvalidInput` if the provided string is not a valid Ethereum address.
     */
public convenience init(address: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePrimitiveError_lift) {
    uniffi_bedrock_fn_constructor_bedrockaddress_new(
        FfiConverterString.lower(address),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_bedrockaddress(pointer, $0) }
    }

    

    
    /**
     * Returns the address as an ABI encoded byte array.
     */
open func asAbiEncode() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bedrock_fn_method_bedrockaddress_as_abi_encode(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the address as an ABI **packed** encoded byte array.
     */
open func asAbiEncodePacked() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_bedrock_fn_method_bedrockaddress_as_abi_encode_packed(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Returns the address as a checksummed string.
     *
     * Reference: <https://eips.ethereum.org/EIPS/eip-55>
     */
open func asChecksummedStr(chainId: UInt64?) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bedrock_fn_method_bedrockaddress_as_checksummed_str(self.uniffiClonePointer(),
        FfiConverterOptionUInt64.lower(chainId),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBedrockAddress: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BedrockAddress

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockAddress {
        return BedrockAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BedrockAddress) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BedrockAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BedrockAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockAddress {
    return try FfiConverterTypeBedrockAddress.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockAddress_lower(_ value: BedrockAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBedrockAddress.lower(value)
}






/**
 * Global configuration for Bedrock
 */
public protocol BedrockConfigProtocol: AnyObject, Sendable {
    
    /**
     * Gets the current environment
     */
    func environment()  -> BedrockEnvironment
    
}
/**
 * Global configuration for Bedrock
 */
open class BedrockConfig: BedrockConfigProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_bedrockconfig(self.pointer, $0) }
    }
    /**
     * Creates a new `BedrockConfig` with the specified environment
     *
     * # Arguments
     * * `environment` - The environment to use for this configuration
     *
     * # Examples
     *
     * ## Swift
     *
     * ```swift
     * let config = BedrockConfig(environment: .production)
     * ```
     */
public convenience init(environment: BedrockEnvironment) {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_bedrockconfig_new(
        FfiConverterTypeBedrockEnvironment_lower(environment),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_bedrockconfig(pointer, $0) }
    }

    

    
    /**
     * Gets the current environment
     */
open func environment() -> BedrockEnvironment  {
    return try!  FfiConverterTypeBedrockEnvironment_lift(try! rustCall() {
    uniffi_bedrock_fn_method_bedrockconfig_environment(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBedrockConfig: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BedrockConfig

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockConfig {
        return BedrockConfig(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BedrockConfig) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BedrockConfig {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BedrockConfig, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockConfig_lift(_ pointer: UnsafeMutableRawPointer) throws -> BedrockConfig {
    return try FfiConverterTypeBedrockConfig.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockConfig_lower(_ value: BedrockConfig) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBedrockConfig.lower(value)
}






/**
 * Verifies AWS Nitro Enclave attestation documents
 *
 * This class performs comprehensive verification of attestation documents including:
 * - COSE Sign1 signature verification
 * - Certificate chain validation against AWS Nitro root certificates
 * - PCR (Platform Configuration Register) value validation
 * - Attestation document freshness checks
 * - Public key extraction
 */
public protocol EnclaveAttestationVerifierProtocol: AnyObject, Sendable {
    
    /**
     * Verifies a base64-encoded attestation document and encrypts the given plaintext
     *
     * This is a convenience method that handles base64 decoding, verifying the attestation document,
     * and encrypting the given plaintext using the enclave's public key using `crypto_box` sealed box.
     *
     * Learn about seal box [here](https://libsodium.gitbook.io/doc/public-key_cryptography/sealed_boxes)
     *
     * # Arguments
     * * `attestation_doc_base64` - The base64-encoded attestation document
     * * `plaintext` - The plaintext to encrypt
     *
     * # Returns
     * A verified attestation containing the enclave's public key and the encrypted plaintext in base64 format.
     *
     * # Errors
     * Returns an error if the base64 decoding fails or the attestation document verification fails
     */
    func verifyAttestationDocumentAndEncrypt(attestationDocBase64: String, plaintext: Data) throws  -> VerifiedAttestationWithCiphertext
    
    /**
     * Verifies a base64-encoded attestation document
     *
     * This is a convenience method that handles base64 decoding and then verifies the document
     *
     * # Arguments
     * * `attestation_doc_base64` - The base64-encoded attestation document
     *
     * # Returns
     * A verified attestation containing the enclave's public key and PCR values
     *
     * # Errors
     * Returns an error if the base64 decoding fails or the attestation document verification fails
     */
    func verifyAttestationDocumentBase64(attestationDocBase64: String) throws  -> VerifiedAttestation
    
}
/**
 * Verifies AWS Nitro Enclave attestation documents
 *
 * This class performs comprehensive verification of attestation documents including:
 * - COSE Sign1 signature verification
 * - Certificate chain validation against AWS Nitro root certificates
 * - PCR (Platform Configuration Register) value validation
 * - Attestation document freshness checks
 * - Public key extraction
 */
open class EnclaveAttestationVerifier: EnclaveAttestationVerifierProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_enclaveattestationverifier(self.pointer, $0) }
    }
    /**
     * Creates a new `EnclaveAttestationVerifier`
     *
     * # Arguments
     * * `environment` - The environment to use for this verifier
     *
     * # Panics
     * Panics if the Bedrock config is not initialized.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_enclaveattestationverifier_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_enclaveattestationverifier(pointer, $0) }
    }

    

    
    /**
     * Verifies a base64-encoded attestation document and encrypts the given plaintext
     *
     * This is a convenience method that handles base64 decoding, verifying the attestation document,
     * and encrypting the given plaintext using the enclave's public key using `crypto_box` sealed box.
     *
     * Learn about seal box [here](https://libsodium.gitbook.io/doc/public-key_cryptography/sealed_boxes)
     *
     * # Arguments
     * * `attestation_doc_base64` - The base64-encoded attestation document
     * * `plaintext` - The plaintext to encrypt
     *
     * # Returns
     * A verified attestation containing the enclave's public key and the encrypted plaintext in base64 format.
     *
     * # Errors
     * Returns an error if the base64 decoding fails or the attestation document verification fails
     */
open func verifyAttestationDocumentAndEncrypt(attestationDocBase64: String, plaintext: Data)throws  -> VerifiedAttestationWithCiphertext  {
    return try  FfiConverterTypeVerifiedAttestationWithCiphertext_lift(try rustCallWithError(FfiConverterTypeEnclaveAttestationError_lift) {
    uniffi_bedrock_fn_method_enclaveattestationverifier_verify_attestation_document_and_encrypt(self.uniffiClonePointer(),
        FfiConverterString.lower(attestationDocBase64),
        FfiConverterData.lower(plaintext),$0
    )
})
}
    
    /**
     * Verifies a base64-encoded attestation document
     *
     * This is a convenience method that handles base64 decoding and then verifies the document
     *
     * # Arguments
     * * `attestation_doc_base64` - The base64-encoded attestation document
     *
     * # Returns
     * A verified attestation containing the enclave's public key and PCR values
     *
     * # Errors
     * Returns an error if the base64 decoding fails or the attestation document verification fails
     */
open func verifyAttestationDocumentBase64(attestationDocBase64: String)throws  -> VerifiedAttestation  {
    return try  FfiConverterTypeVerifiedAttestation_lift(try rustCallWithError(FfiConverterTypeEnclaveAttestationError_lift) {
    uniffi_bedrock_fn_method_enclaveattestationverifier_verify_attestation_document_base64(self.uniffiClonePointer(),
        FfiConverterString.lower(attestationDocBase64),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnclaveAttestationVerifier: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EnclaveAttestationVerifier

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EnclaveAttestationVerifier {
        return EnclaveAttestationVerifier(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EnclaveAttestationVerifier) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnclaveAttestationVerifier {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EnclaveAttestationVerifier, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnclaveAttestationVerifier_lift(_ pointer: UnsafeMutableRawPointer) throws -> EnclaveAttestationVerifier {
    return try FfiConverterTypeEnclaveAttestationVerifier.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnclaveAttestationVerifier_lower(_ value: EnclaveAttestationVerifier) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEnclaveAttestationVerifier.lower(value)
}






/**
 * Trait representing a filesystem that can be implemented by the native side
 */
public protocol FileSystem: AnyObject, Sendable {
    
    /**
     * Check if a file exists at the given path
     *
     * # Errors
     * - `FileSystemError` if the operation fails
     */
    func fileExists(filePath: String) throws  -> Bool
    
    /**
     * Read file contents
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be read
     * - `FileSystemError::FileDoesNotExist` if the file doesn't exist
     */
    func readFile(filePath: String) throws  -> Data
    
    /**
     * List files in a specific directory. No recursion and no subdirectories are returned.
     *
     * # Notes
     * Files are returned without the directory path. Only the file name is returned.
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the directory cannot be listed
     */
    func listFilesAtDirectory(folderPath: String) throws  -> [String]
    
    /**
     * Read a specific byte range from a file
     *
     * Returns up to `max_length` bytes starting at `offset`. Returns an empty vector
     * when `offset` is at or beyond the end of the file.
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be read
     * - `FileSystemError::FileDoesNotExist` if the file doesn't exist
     */
    func readFileRange(filePath: String, offset: UInt64, maxLength: UInt64) throws  -> Data
    
    /**
     * Write file contents
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be written, with details about the failure
     */
    func writeFile(filePath: String, fileBuffer: Data) throws 
    
    /**
     * Delete a file
     *
     * # Errors
     * - `FileSystemError::FileDoesNotExist` if the file does not exist
     * - `FileSystemError::IoFailure` if the file cannot be deleted
     */
    func deleteFile(filePath: String) throws 
    
}
/**
 * Trait representing a filesystem that can be implemented by the native side
 */
open class FileSystemImpl: FileSystem, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_filesystem(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_filesystem(pointer, $0) }
    }

    

    
    /**
     * Check if a file exists at the given path
     *
     * # Errors
     * - `FileSystemError` if the operation fails
     */
open func fileExists(filePath: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_file_exists(self.uniffiClonePointer(),
        FfiConverterString.lower(filePath),$0
    )
})
}
    
    /**
     * Read file contents
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be read
     * - `FileSystemError::FileDoesNotExist` if the file doesn't exist
     */
open func readFile(filePath: String)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_read_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filePath),$0
    )
})
}
    
    /**
     * List files in a specific directory. No recursion and no subdirectories are returned.
     *
     * # Notes
     * Files are returned without the directory path. Only the file name is returned.
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the directory cannot be listed
     */
open func listFilesAtDirectory(folderPath: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_list_files_at_directory(self.uniffiClonePointer(),
        FfiConverterString.lower(folderPath),$0
    )
})
}
    
    /**
     * Read a specific byte range from a file
     *
     * Returns up to `max_length` bytes starting at `offset`. Returns an empty vector
     * when `offset` is at or beyond the end of the file.
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be read
     * - `FileSystemError::FileDoesNotExist` if the file doesn't exist
     */
open func readFileRange(filePath: String, offset: UInt64, maxLength: UInt64)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_read_file_range(self.uniffiClonePointer(),
        FfiConverterString.lower(filePath),
        FfiConverterUInt64.lower(offset),
        FfiConverterUInt64.lower(maxLength),$0
    )
})
}
    
    /**
     * Write file contents
     *
     * # Errors
     * - `FileSystemError::IoFailure` if the file cannot be written, with details about the failure
     */
open func writeFile(filePath: String, fileBuffer: Data)throws   {try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_write_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filePath),
        FfiConverterData.lower(fileBuffer),$0
    )
}
}
    
    /**
     * Delete a file
     *
     * # Errors
     * - `FileSystemError::FileDoesNotExist` if the file does not exist
     * - `FileSystemError::IoFailure` if the file cannot be deleted
     */
open func deleteFile(filePath: String)throws   {try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystem_delete_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filePath),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceFileSystem {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceFileSystem] = [UniffiVTableCallbackInterfaceFileSystem(
        fileExists: { (
            uniffiHandle: UInt64,
            filePath: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<Int8>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Bool in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.fileExists(
                     filePath: try FfiConverterString.lift(filePath)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterBool.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        readFile: { (
            uniffiHandle: UInt64,
            filePath: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.readFile(
                     filePath: try FfiConverterString.lift(filePath)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        listFilesAtDirectory: { (
            uniffiHandle: UInt64,
            folderPath: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> [String] in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.listFilesAtDirectory(
                     folderPath: try FfiConverterString.lift(folderPath)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterSequenceString.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        readFileRange: { (
            uniffiHandle: UInt64,
            filePath: RustBuffer,
            offset: UInt64,
            maxLength: UInt64,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Data in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.readFileRange(
                     filePath: try FfiConverterString.lift(filePath),
                     offset: try FfiConverterUInt64.lift(offset),
                     maxLength: try FfiConverterUInt64.lift(maxLength)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterData.lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        writeFile: { (
            uniffiHandle: UInt64,
            filePath: RustBuffer,
            fileBuffer: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.writeFile(
                     filePath: try FfiConverterString.lift(filePath),
                     fileBuffer: try FfiConverterData.lift(fileBuffer)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        deleteFile: { (
            uniffiHandle: UInt64,
            filePath: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeFileSystem.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.deleteFile(
                     filePath: try FfiConverterString.lift(filePath)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeFileSystemError_lower
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeFileSystem.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface FileSystem: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitFileSystem() {
    uniffi_bedrock_fn_init_callback_vtable_filesystem(UniffiCallbackInterfaceFileSystem.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileSystem: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<FileSystem>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileSystem

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystem {
        return FileSystemImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileSystem) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystem {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileSystem, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystem_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystem {
    return try FfiConverterTypeFileSystem.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystem_lower(_ value: FileSystem) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileSystem.lower(value)
}






/**
 * Test struct to verify filesystem middleware injection
 */
public protocol FileSystemTesterProtocol: AnyObject, Sendable {
    
    /**
     * Tests deleting a file
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
    func testDeleteFile(filename: String) throws 
    
    /**
     * Tests file existence check
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
    func testFileExists(filename: String) throws  -> Bool
    
    /**
     * Tests listing files in the current directory
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
    func testListFilesAtDirectory() throws  -> [String]
    
    /**
     * Tests reading a file using the injected filesystem middleware
     *
     * # Errors
     * - `FileSystemTestError` if filesystem operations fail
     */
    func testReadFile(filename: String) throws  -> String
    
    /**
     * Tests writing a file using the injected filesystem middleware
     *
     * # Errors
     * - `FileSystemTestError` if filesystem operations fail
     */
    func testWriteFile(filename: String, content: String) throws 
    
}
/**
 * Test struct to verify filesystem middleware injection
 */
open class FileSystemTester: FileSystemTesterProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_filesystemtester(self.pointer, $0) }
    }
    /**
     * Creates a new `FileSystemTester` instance
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_filesystemtester_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_filesystemtester(pointer, $0) }
    }

    

    
    /**
     * Tests deleting a file
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
open func testDeleteFile(filename: String)throws   {try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystemtester_test_delete_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filename),$0
    )
}
}
    
    /**
     * Tests file existence check
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
open func testFileExists(filename: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystemtester_test_file_exists(self.uniffiClonePointer(),
        FfiConverterString.lower(filename),$0
    )
})
}
    
    /**
     * Tests listing files in the current directory
     *
     * # Errors
     * - `FileSystemError` if filesystem operations fail
     */
open func testListFilesAtDirectory()throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeFileSystemError_lift) {
    uniffi_bedrock_fn_method_filesystemtester_test_list_files_at_directory(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Tests reading a file using the injected filesystem middleware
     *
     * # Errors
     * - `FileSystemTestError` if filesystem operations fail
     */
open func testReadFile(filename: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeFileSystemTestError_lift) {
    uniffi_bedrock_fn_method_filesystemtester_test_read_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filename),$0
    )
})
}
    
    /**
     * Tests writing a file using the injected filesystem middleware
     *
     * # Errors
     * - `FileSystemTestError` if filesystem operations fail
     */
open func testWriteFile(filename: String, content: String)throws   {try rustCallWithError(FfiConverterTypeFileSystemTestError_lift) {
    uniffi_bedrock_fn_method_filesystemtester_test_write_file(self.uniffiClonePointer(),
        FfiConverterString.lower(filename),
        FfiConverterString.lower(content),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileSystemTester: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileSystemTester

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemTester {
        return FileSystemTester(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileSystemTester) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemTester {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileSystemTester, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemTester_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileSystemTester {
    return try FfiConverterTypeFileSystemTester.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemTester_lower(_ value: FileSystemTester) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileSystemTester.lower(value)
}






/**
 * A wrapper around hex-encoded bytes (may or may not be a number).
 *
 * This is used to ensure that the hex string is properly formatted and the output is always prefixed with "0x".
 * Ensures consistency in expected output format.
 *
 * # Examples
 * ```
 * use bedrock::primitives::HexEncodedData;
 * let hex_string = HexEncodedData::new("0x1234567890abcdef");
 * ```
 */
public protocol HexEncodedDataProtocol: AnyObject, Sendable {
    
    /**
     * Returns the wrapped hex string as a String. Re-wraps `Display` trait for foreign code.
     */
    func toHexString()  -> String
    
    /**
     * Converts the wrapped hex string into a `Bytes` struct.
     *
     * # Errors
     * - `PrimitiveError::Generic` in the unexpected case that the hex string is not validly encoded hex data.
     * This should never happen as this is verified on initialization.
     */
    func toVec() throws  -> Data
    
}
/**
 * A wrapper around hex-encoded bytes (may or may not be a number).
 *
 * This is used to ensure that the hex string is properly formatted and the output is always prefixed with "0x".
 * Ensures consistency in expected output format.
 *
 * # Examples
 * ```
 * use bedrock::primitives::HexEncodedData;
 * let hex_string = HexEncodedData::new("0x1234567890abcdef");
 * ```
 */
open class HexEncodedData: HexEncodedDataProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_hexencodeddata(self.pointer, $0) }
    }
    /**
     * Initializes a new `HexEncodedData` from a hex string.
     *
     * # Arguments
     * * `s` - The hex string to initialize the `HexEncodedData` from. May or may not be prefixed with "0x".
     *
     * # Errors
     * - `PrimitiveError::InvalidHexString` if the provided string is not validly encoded hex data.
     */
public convenience init(s: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypePrimitiveError_lift) {
    uniffi_bedrock_fn_constructor_hexencodeddata_new(
        FfiConverterString.lower(s),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_hexencodeddata(pointer, $0) }
    }

    

    
    /**
     * Returns the wrapped hex string as a String. Re-wraps `Display` trait for foreign code.
     */
open func toHexString() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bedrock_fn_method_hexencodeddata_to_hex_string(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Converts the wrapped hex string into a `Bytes` struct.
     *
     * # Errors
     * - `PrimitiveError::Generic` in the unexpected case that the hex string is not validly encoded hex data.
     * This should never happen as this is verified on initialization.
     */
open func toVec()throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypePrimitiveError_lift) {
    uniffi_bedrock_fn_method_hexencodeddata_to_vec(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHexEncodedData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = HexEncodedData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> HexEncodedData {
        return HexEncodedData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: HexEncodedData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HexEncodedData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: HexEncodedData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHexEncodedData_lift(_ pointer: UnsafeMutableRawPointer) throws -> HexEncodedData {
    return try FfiConverterTypeHexEncodedData.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHexEncodedData_lower(_ value: HexEncodedData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeHexEncodedData.lower(value)
}






/**
 * Trait representing a logger that can log messages at various levels.
 *
 * This trait should be implemented by any logger that wants to receive log messages.
 * It is exported via `UniFFI` for use in foreign languages.
 *
 * # Examples
 *
 * Implementing the `Logger` trait:
 *
 * ```rust
 *
 * use bedrock::primitives::logger::{Logger, LogLevel};
 *
 * struct MyLogger;
 *
 * impl Logger for MyLogger {
 * fn log(&self, level: LogLevel, message: String) {
 * println!("[{:?}] {}", level, message);
 * }
 * }
 * ```
 *
 * ## swift
 *
 * ```swift
 * class BedrockCoreLoggerBridge: Bedrock.Logger {
 * static let shared = BedrockCoreLoggerBridge()
 *
 * func log(level: Bedrock.LogLevel, message: String) {
 * Log.log(level.toCoreLevel(), message)
 * }
 * }
 *
 * public func setupBedrockLogger() {
 * Bedrock.setLogger(logger: BedrockCoreLoggerBridge.shared)
 * }
 *
 * extension Bedrock.LogLevel {
 * func toCoreLevel() -> WorldAppCore.LogLevel {
 * switch self {
 * case .debug, .trace:
 * return .debug
 * case .info:
 * return .info
 * case .error:
 * return .error
 * case .warn:
 * return .warn
 * }
 * }
 * }
 * ```
 *
 * ### In app delegate
 *
 * ```swift
 * setupBedrockLogger() // Call this only once!!!
 * ```
 */
public protocol Logger: AnyObject, Sendable {
    
    /**
     * Logs a message at the specified log level.
     *
     * # Arguments
     *
     * * `level` - The severity level of the log message.
     * * `message` - The log message to be recorded.
     */
    func log(level: LogLevel, message: String) 
    
}
/**
 * Trait representing a logger that can log messages at various levels.
 *
 * This trait should be implemented by any logger that wants to receive log messages.
 * It is exported via `UniFFI` for use in foreign languages.
 *
 * # Examples
 *
 * Implementing the `Logger` trait:
 *
 * ```rust
 *
 * use bedrock::primitives::logger::{Logger, LogLevel};
 *
 * struct MyLogger;
 *
 * impl Logger for MyLogger {
 * fn log(&self, level: LogLevel, message: String) {
 * println!("[{:?}] {}", level, message);
 * }
 * }
 * ```
 *
 * ## swift
 *
 * ```swift
 * class BedrockCoreLoggerBridge: Bedrock.Logger {
 * static let shared = BedrockCoreLoggerBridge()
 *
 * func log(level: Bedrock.LogLevel, message: String) {
 * Log.log(level.toCoreLevel(), message)
 * }
 * }
 *
 * public func setupBedrockLogger() {
 * Bedrock.setLogger(logger: BedrockCoreLoggerBridge.shared)
 * }
 *
 * extension Bedrock.LogLevel {
 * func toCoreLevel() -> WorldAppCore.LogLevel {
 * switch self {
 * case .debug, .trace:
 * return .debug
 * case .info:
 * return .info
 * case .error:
 * return .error
 * case .warn:
 * return .warn
 * }
 * }
 * }
 * ```
 *
 * ### In app delegate
 *
 * ```swift
 * setupBedrockLogger() // Call this only once!!!
 * ```
 */
open class LoggerImpl: Logger, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_logger(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_logger(pointer, $0) }
    }

    

    
    /**
     * Logs a message at the specified log level.
     *
     * # Arguments
     *
     * * `level` - The severity level of the log message.
     * * `message` - The log message to be recorded.
     */
open func log(level: LogLevel, message: String)  {try! rustCall() {
    uniffi_bedrock_fn_method_logger_log(self.uniffiClonePointer(),
        FfiConverterTypeLogLevel_lower(level),
        FfiConverterString.lower(message),$0
    )
}
}
    

}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLogger {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLogger] = [UniffiVTableCallbackInterfaceLogger(
        log: { (
            uniffiHandle: UInt64,
            level: RustBuffer,
            message: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterTypeLogger.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.log(
                     level: try FfiConverterTypeLogLevel_lift(level),
                     message: try FfiConverterString.lift(message)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            let result = try? FfiConverterTypeLogger.handleMap.remove(handle: uniffiHandle)
            if result == nil {
                print("Uniffi callback interface Logger: handle missing in uniffiFree")
            }
        }
    )]
}

private func uniffiCallbackInitLogger() {
    uniffi_bedrock_fn_init_callback_vtable_logger(UniffiCallbackInterfaceLogger.vtable)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogger: FfiConverter {
    fileprivate static let handleMap = UniffiHandleMap<Logger>()

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Logger

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
        return LoggerImpl(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Logger) -> UnsafeMutableRawPointer {
        guard let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: handleMap.insert(obj: value))) else {
            fatalError("Cast to UnsafeMutableRawPointer failed")
        }
        return ptr
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Logger {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Logger, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lift(_ pointer: UnsafeMutableRawPointer) throws -> Logger {
    return try FfiConverterTypeLogger.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogger_lower(_ value: Logger) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLogger.lower(value)
}






/**
 * Manager responsible for reading and writing backup manifests and coordinating sync.
 *
 * Documentation: <https://docs.toolsforhumanity.com/world-app/backup/structure-and-sync>
 */
public protocol ManifestManagerProtocol: AnyObject, Sendable {
    
    /**
     * Returns files recorded in the global manifest after verifying local is not stale vs remote.
     *
     * The caller must supply an HTTP client and signer to perform the gate. This method does not mutate state.
     *
     * # Errors
     * Returns an error if the remote hash does not match local or if network/IO errors occur.
     */
    func listFiles(designator: BackupFileDesignator) async throws  -> [String]
    
    /**
     * Removes a specific file entry. Triggers a backup sync.
     *
     * # Errors
     * - Returns an error if the file does not exist in the backup.
     * - Returns an error if the remote hash does not match local (remote is ahead).
     * - Returns an error if serialization fails.
     */
    func removeFile(filePath: String, rootSecret: String, backupKeypairPublicKey: String) async throws 
    
    /**
     * Replaces all the file entries for a given designator by removing all existing entries for a given designator
     * and adding a new file.
     *
     * # Errors
     * Returns an error if the remote hash does not match local or downstream operations fail.
     */
    func replaceAllFilesForDesignator(designator: BackupFileDesignator, newFilePath: String, rootSecret: String, backupKeypairPublicKey: String) async throws 
    
    /**
     * Adds a file entry for a given designator. Will trigger a backup sync.
     *
     * # Errors
     * - Returns an error if remote hash does not match local (remote is ahead).
     * - Returns an error if serialization fails.
     */
    func storeFile(designator: BackupFileDesignator, filePath: String, rootSecret: String, backupKeypairPublicKey: String) async throws 
    
}
/**
 * Manager responsible for reading and writing backup manifests and coordinating sync.
 *
 * Documentation: <https://docs.toolsforhumanity.com/world-app/backup/structure-and-sync>
 */
open class ManifestManager: ManifestManagerProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_manifestmanager(self.pointer, $0) }
    }
    /**
     * Constructs a new `ManifestManager` instance with a file system middleware scoped to backups.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_manifestmanager_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_manifestmanager(pointer, $0) }
    }

    

    
    /**
     * Returns files recorded in the global manifest after verifying local is not stale vs remote.
     *
     * The caller must supply an HTTP client and signer to perform the gate. This method does not mutate state.
     *
     * # Errors
     * Returns an error if the remote hash does not match local or if network/IO errors occur.
     */
open func listFiles(designator: BackupFileDesignator)async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_manifestmanager_list_files(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBackupFileDesignator_lower(designator)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_rust_buffer,
            completeFunc: ffi_bedrock_rust_future_complete_rust_buffer,
            freeFunc: ffi_bedrock_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeBackupError_lift
        )
}
    
    /**
     * Removes a specific file entry. Triggers a backup sync.
     *
     * # Errors
     * - Returns an error if the file does not exist in the backup.
     * - Returns an error if the remote hash does not match local (remote is ahead).
     * - Returns an error if serialization fails.
     */
open func removeFile(filePath: String, rootSecret: String, backupKeypairPublicKey: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_manifestmanager_remove_file(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(filePath),FfiConverterString.lower(rootSecret),FfiConverterString.lower(backupKeypairPublicKey)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_void,
            completeFunc: ffi_bedrock_rust_future_complete_void,
            freeFunc: ffi_bedrock_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeBackupError_lift
        )
}
    
    /**
     * Replaces all the file entries for a given designator by removing all existing entries for a given designator
     * and adding a new file.
     *
     * # Errors
     * Returns an error if the remote hash does not match local or downstream operations fail.
     */
open func replaceAllFilesForDesignator(designator: BackupFileDesignator, newFilePath: String, rootSecret: String, backupKeypairPublicKey: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_manifestmanager_replace_all_files_for_designator(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBackupFileDesignator_lower(designator),FfiConverterString.lower(newFilePath),FfiConverterString.lower(rootSecret),FfiConverterString.lower(backupKeypairPublicKey)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_void,
            completeFunc: ffi_bedrock_rust_future_complete_void,
            freeFunc: ffi_bedrock_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeBackupError_lift
        )
}
    
    /**
     * Adds a file entry for a given designator. Will trigger a backup sync.
     *
     * # Errors
     * - Returns an error if remote hash does not match local (remote is ahead).
     * - Returns an error if serialization fails.
     */
open func storeFile(designator: BackupFileDesignator, filePath: String, rootSecret: String, backupKeypairPublicKey: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_manifestmanager_store_file(
                    self.uniffiClonePointer(),
                    FfiConverterTypeBackupFileDesignator_lower(designator),FfiConverterString.lower(filePath),FfiConverterString.lower(rootSecret),FfiConverterString.lower(backupKeypairPublicKey)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_void,
            completeFunc: ffi_bedrock_rust_future_complete_void,
            freeFunc: ffi_bedrock_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeBackupError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeManifestManager: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ManifestManager

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestManager {
        return ManifestManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ManifestManager) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ManifestManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ManifestManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> ManifestManager {
    return try FfiConverterTypeManifestManager.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeManifestManager_lower(_ value: ManifestManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeManifestManager.lower(value)
}






/**
 * The `RootKey` is a 32-byte secret key from which other keys are derived for use throughout World App.
 *
 * Debug trait is safe because the key is stored in a `SecretBox`.
 */
public protocol RootKeyProtocol: AnyObject, Sendable {
    
    func isEqualTo(other: RootKey)  -> Bool
    
    func isV0()  -> Bool
    
}
/**
 * The `RootKey` is a 32-byte secret key from which other keys are derived for use throughout World App.
 *
 * Debug trait is safe because the key is stored in a `SecretBox`.
 */
open class RootKey: RootKeyProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_rootkey(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_rootkey(pointer, $0) }
    }

    
    /**
     * Initialize an existing `RootKey` from a JSON string
     */
public static func fromJson(jsonStr: String)throws  -> RootKey  {
    return try  FfiConverterTypeRootKey_lift(try rustCallWithError(FfiConverterTypeRootKeyError_lift) {
    uniffi_bedrock_fn_constructor_rootkey_from_json(
        FfiConverterString.lower(jsonStr),$0
    )
})
}
    
    /**
     * Generates a new random `RootKey` using the system CSPRNG.
     *
     * # Panics
     * Will panic if there is an error with the CSPRNG. This terminates the app.
     */
public static func newRandom() -> RootKey  {
    return try!  FfiConverterTypeRootKey_lift(try! rustCall() {
    uniffi_bedrock_fn_constructor_rootkey_new_random($0
    )
})
}
    

    
open func isEqualTo(other: RootKey) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_method_rootkey_is_equal_to(self.uniffiClonePointer(),
        FfiConverterTypeRootKey_lower(other),$0
    )
})
}
    
open func isV0() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_method_rootkey_is_v0(self.uniffiClonePointer(),$0
    )
})
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRootKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RootKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RootKey {
        return RootKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RootKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RootKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RootKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRootKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> RootKey {
    return try FfiConverterTypeRootKey.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRootKey_lower(_ value: RootKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRootKey.lower(value)
}






/**
 * A Safe Smart Account (previously Gnosis Safe) is the representation of a Safe smart contract.
 *
 * It is used to sign messages, transactions and typed data on behalf of the Safe smart contract.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account>
 */
public protocol SafeSmartAccountProtocol: AnyObject, Sendable {
    
    /**
     * Signs a string message using the `personal_sign` method on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `message`: The message to sign. Do not add the EIP-191 prefix, or typehash prefixes. Should be the raw message.
     *
     * # Errors
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func personalSign(chainId: UInt32, message: String) throws  -> HexEncodedData
    
    /**
     * Crafts and signs a 4337 user operation on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the user operation is being signed.
     * - `user_operation`: The user operation to sign.
     *
     * # Errors
     * - Will throw an error if the user operation is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     *
     * # Examples
     * ```rust
     * use bedrock::smart_account::{SafeSmartAccount};
     * use bedrock::transactions::foreign::UnparsedUserOperation;
     * use bedrock::primitives::Network;
     *
     * let safe = SafeSmartAccount::new(
     * // this is Anvil's default private key, it is a test secret
     * "ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80".to_string(),
     * "0x4564420674EA68fcc61b463C0494807C759d47e6",
     * )
     * .unwrap();
     *
     * // This would normally be crafted by the user, or requested by Mini Apps.
     * let user_op = UnparsedUserOperation {
     * sender:"0xf1390a26bd60d83a4e38c7be7be1003c616296ad".to_string(),
     * nonce: "0xb14292cd79fae7d79284d4e6304fb58e21d579c13a75eed80000000000000000".to_string(),
     * call_data:  "0x7bb3742800000000000000000000000079a02482a880bce3f13e09da970dc34db4cd24d10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ce2111f9ab8909b71ebadc9b6458daefe069eda4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000".to_string(),
     * signature:  "0x000012cea6000000967a7600ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".to_string(),
     * call_gas_limit: "0xabb8".to_string(),
     * verification_gas_limit: "0xfa07".to_string(),
     * pre_verification_gas: "0x8e4d78".to_string(),
     * max_fee_per_gas: "0x1af6f".to_string(),
     * max_priority_fee_per_gas: "0x1adb0".to_string(),
     * paymaster: Some("0xEF725Aa22d43Ea69FB22bE2EBe6ECa205a6BCf5B".to_string()),
     * paymaster_verification_gas_limit: "0x7415".to_string(),
     * paymaster_post_op_gas_limit: "0x".to_string(),
     * paymaster_data: Some("000000000000000067789a97c4af0f8ae7acc9237c8f9611a0eb4662009d366b8defdf5f68fed25d22ca77be64b8eef49d917c3f8642ca539571594a84be9d0ee717c099160b79a845bea2111b".to_string()),
     * factory: None,
     * factory_data: None,
     * };
     *
     * let signature = safe.sign_4337_op(Network::WorldChain as u32, user_op).unwrap();
     *
     * println!("Signature: {}", signature.to_hex_string());
     * ```
     */
    func sign4337Op(chainId: UInt32, userOperation: UnparsedUserOperation) throws  -> HexEncodedData
    
    /**
     * Signs a `Permit2` transfer on behalf of the Safe Smart Account.
     *
     * Used by Mini Apps where users approve transfers for specific tokens and amounts for a period of time on their behalf.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed.
     * - `transfer`: The `Permit2` transfer to sign.
     *
     * # Errors
     * - Will throw an error if the transfer is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signPermit2Transfer(chainId: UInt32, transfer: UnparsedPermitTransferFrom) throws  -> HexEncodedData
    
    /**
     * Signs a transaction on behalf of the Safe Smart Account.
     *
     * This allows execution of normal transactions for the Safe.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the transaction is being signed.
     * - `transaction`: The transaction to sign.
     *
     * # Errors
     * - Will throw an error if the transaction is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signTransaction(chainId: UInt32, transaction: SafeTransaction) throws  -> HexEncodedData
    
    /**
     * Signs an arbitrary EIP-712 typed data message on behalf of the Safe Smart Account.
     *
     * Please note that certain primary types are restricted and cannot be signed. For example Permit2's `PermitTransferFrom` is restricted.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `stringified_typed_data`: A JSON string representing the typed data as per EIP-712.
     *
     * # Errors
     * - Will throw an error if the typed data is not a valid JSON string.
     * - Will throw an error if the typed data is not a valid EIP-712 typed data message.
     * - Will throw an error if the signature process unexpectedly fails.
     */
    func signTypedData(chainId: UInt32, stringifiedTypedData: String) throws  -> HexEncodedData
    
    /**
     * Allows executing an ERC-20 token transfer **on World Chain**.
     *
     * # Arguments
     * - `token_address`: The address of the ERC-20 token to transfer.
     * - `to_address`: The address of the recipient.
     * - `amount`: The amount of tokens to transfer as a stringified integer with the decimals of the token (e.g. 18 for USDC or WLD)
     * - `transfer_association`: Metadata value. The association of the transfer.
     *
     * # Example
     *
     * ```rust,no_run
     * use bedrock::smart_account::SafeSmartAccount;
     * use bedrock::transactions::TransactionError;
     * use bedrock::primitives::Network;
     *
     * # async fn example() -> Result<(), TransactionError> {
     * // Assume we have a configured SafeSmartAccount
     * # let safe_account = SafeSmartAccount::new("test_key".to_string(), "0x1234567890123456789012345678901234567890").unwrap();
     *
     * // Transfer USDC on World Chain
     * let tx_hash = safe_account.transaction_transfer(
     * "0x79A02482A880BCE3F13E09Da970dC34DB4cD24d1", // USDC on World Chain
     * "0x1234567890123456789012345678901234567890",
     * "1000000", // 1 USDC (6 decimals)
     * None,
     * ).await?;
     *
     * println!("Transaction hash: {}", tx_hash.to_hex_string());
     * # Ok(())
     * # }
     * ```
     *
     * # Errors
     * - Will throw a parsing error if any of the provided attributes are invalid.
     * - Will throw an RPC error if the transaction submission fails.
     * - Will throw an error if the global HTTP client has not been initialized.
     */
    func transactionTransfer(tokenAddress: String, toAddress: String, amount: String, transferAssociation: TransferAssociation?) async throws  -> HexEncodedData
    
}
/**
 * A Safe Smart Account (previously Gnosis Safe) is the representation of a Safe smart contract.
 *
 * It is used to sign messages, transactions and typed data on behalf of the Safe smart contract.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account>
 */
open class SafeSmartAccount: SafeSmartAccountProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_safesmartaccount(self.pointer, $0) }
    }
    /**
     * Initializes a new `SafeSmartAccount` instance with the given EOA signing key.
     *
     * # Arguments
     * - `private_key`: A hex-encoded string representing the **secret key** of the EOA who is an owner in the Safe.
     * - `wallet_address`: The address of the Safe Smart Account (i.e. the deployed smart contract). This is required because
     * some legacy versions of the wallet were computed differently. Today, it cannot be deterministically computed for all
     * users. This is also necessary to support signing for Safes deployed by third-party Mini App devs, where the
     * wallet address is only known at runtime.
     *
     * # Errors
     * - Will return an error if the key is not a validly encoded hex string.
     * - Will return an error if the key is not a valid point in the k256 curve.
     */
public convenience init(privateKey: String, walletAddress: String)throws  {
    let pointer =
        try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_constructor_safesmartaccount_new(
        FfiConverterString.lower(privateKey),
        FfiConverterString.lower(walletAddress),$0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_safesmartaccount(pointer, $0) }
    }

    

    
    /**
     * Signs a string message using the `personal_sign` method on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `message`: The message to sign. Do not add the EIP-191 prefix, or typehash prefixes. Should be the raw message.
     *
     * # Errors
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func personalSign(chainId: UInt32, message: String)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_personal_sign(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterString.lower(message),$0
    )
})
}
    
    /**
     * Crafts and signs a 4337 user operation on behalf of the Safe Smart Account.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the user operation is being signed.
     * - `user_operation`: The user operation to sign.
     *
     * # Errors
     * - Will throw an error if the user operation is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     *
     * # Examples
     * ```rust
     * use bedrock::smart_account::{SafeSmartAccount};
     * use bedrock::transactions::foreign::UnparsedUserOperation;
     * use bedrock::primitives::Network;
     *
     * let safe = SafeSmartAccount::new(
     * // this is Anvil's default private key, it is a test secret
     * "ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80".to_string(),
     * "0x4564420674EA68fcc61b463C0494807C759d47e6",
     * )
     * .unwrap();
     *
     * // This would normally be crafted by the user, or requested by Mini Apps.
     * let user_op = UnparsedUserOperation {
     * sender:"0xf1390a26bd60d83a4e38c7be7be1003c616296ad".to_string(),
     * nonce: "0xb14292cd79fae7d79284d4e6304fb58e21d579c13a75eed80000000000000000".to_string(),
     * call_data:  "0x7bb3742800000000000000000000000079a02482a880bce3f13e09da970dc34db4cd24d10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044a9059cbb000000000000000000000000ce2111f9ab8909b71ebadc9b6458daefe069eda4000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000".to_string(),
     * signature:  "0x000012cea6000000967a7600ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff".to_string(),
     * call_gas_limit: "0xabb8".to_string(),
     * verification_gas_limit: "0xfa07".to_string(),
     * pre_verification_gas: "0x8e4d78".to_string(),
     * max_fee_per_gas: "0x1af6f".to_string(),
     * max_priority_fee_per_gas: "0x1adb0".to_string(),
     * paymaster: Some("0xEF725Aa22d43Ea69FB22bE2EBe6ECa205a6BCf5B".to_string()),
     * paymaster_verification_gas_limit: "0x7415".to_string(),
     * paymaster_post_op_gas_limit: "0x".to_string(),
     * paymaster_data: Some("000000000000000067789a97c4af0f8ae7acc9237c8f9611a0eb4662009d366b8defdf5f68fed25d22ca77be64b8eef49d917c3f8642ca539571594a84be9d0ee717c099160b79a845bea2111b".to_string()),
     * factory: None,
     * factory_data: None,
     * };
     *
     * let signature = safe.sign_4337_op(Network::WorldChain as u32, user_op).unwrap();
     *
     * println!("Signature: {}", signature.to_hex_string());
     * ```
     */
open func sign4337Op(chainId: UInt32, userOperation: UnparsedUserOperation)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_4337_op(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypeUnparsedUserOperation_lower(userOperation),$0
    )
})
}
    
    /**
     * Signs a `Permit2` transfer on behalf of the Safe Smart Account.
     *
     * Used by Mini Apps where users approve transfers for specific tokens and amounts for a period of time on their behalf.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed.
     * - `transfer`: The `Permit2` transfer to sign.
     *
     * # Errors
     * - Will throw an error if the transfer is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signPermit2Transfer(chainId: UInt32, transfer: UnparsedPermitTransferFrom)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_permit2_transfer(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypeUnparsedPermitTransferFrom_lower(transfer),$0
    )
})
}
    
    /**
     * Signs a transaction on behalf of the Safe Smart Account.
     *
     * This allows execution of normal transactions for the Safe.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the transaction is being signed.
     * - `transaction`: The transaction to sign.
     *
     * # Errors
     * - Will throw an error if the transaction is invalid, particularly if any attribute is not valid.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signTransaction(chainId: UInt32, transaction: SafeTransaction)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_transaction(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterTypeSafeTransaction_lower(transaction),$0
    )
})
}
    
    /**
     * Signs an arbitrary EIP-712 typed data message on behalf of the Safe Smart Account.
     *
     * Please note that certain primary types are restricted and cannot be signed. For example Permit2's `PermitTransferFrom` is restricted.
     *
     * # Arguments
     * - `chain_id`: The chain ID of the chain where the message is being signed. While technically the chain ID is a `U256` in EVM, we limit
     * to sensible `u32` (which works well with foreign code).
     * - `stringified_typed_data`: A JSON string representing the typed data as per EIP-712.
     *
     * # Errors
     * - Will throw an error if the typed data is not a valid JSON string.
     * - Will throw an error if the typed data is not a valid EIP-712 typed data message.
     * - Will throw an error if the signature process unexpectedly fails.
     */
open func signTypedData(chainId: UInt32, stringifiedTypedData: String)throws  -> HexEncodedData  {
    return try  FfiConverterTypeHexEncodedData_lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_method_safesmartaccount_sign_typed_data(self.uniffiClonePointer(),
        FfiConverterUInt32.lower(chainId),
        FfiConverterString.lower(stringifiedTypedData),$0
    )
})
}
    
    /**
     * Allows executing an ERC-20 token transfer **on World Chain**.
     *
     * # Arguments
     * - `token_address`: The address of the ERC-20 token to transfer.
     * - `to_address`: The address of the recipient.
     * - `amount`: The amount of tokens to transfer as a stringified integer with the decimals of the token (e.g. 18 for USDC or WLD)
     * - `transfer_association`: Metadata value. The association of the transfer.
     *
     * # Example
     *
     * ```rust,no_run
     * use bedrock::smart_account::SafeSmartAccount;
     * use bedrock::transactions::TransactionError;
     * use bedrock::primitives::Network;
     *
     * # async fn example() -> Result<(), TransactionError> {
     * // Assume we have a configured SafeSmartAccount
     * # let safe_account = SafeSmartAccount::new("test_key".to_string(), "0x1234567890123456789012345678901234567890").unwrap();
     *
     * // Transfer USDC on World Chain
     * let tx_hash = safe_account.transaction_transfer(
     * "0x79A02482A880BCE3F13E09Da970dC34DB4cD24d1", // USDC on World Chain
     * "0x1234567890123456789012345678901234567890",
     * "1000000", // 1 USDC (6 decimals)
     * None,
     * ).await?;
     *
     * println!("Transaction hash: {}", tx_hash.to_hex_string());
     * # Ok(())
     * # }
     * ```
     *
     * # Errors
     * - Will throw a parsing error if any of the provided attributes are invalid.
     * - Will throw an RPC error if the transaction submission fails.
     * - Will throw an error if the global HTTP client has not been initialized.
     */
open func transactionTransfer(tokenAddress: String, toAddress: String, amount: String, transferAssociation: TransferAssociation?)async throws  -> HexEncodedData  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_safesmartaccount_transaction_transfer(
                    self.uniffiClonePointer(),
                    FfiConverterString.lower(tokenAddress),FfiConverterString.lower(toAddress),FfiConverterString.lower(amount),FfiConverterOptionTypeTransferAssociation.lower(transferAssociation)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_pointer,
            completeFunc: ffi_bedrock_rust_future_complete_pointer,
            freeFunc: ffi_bedrock_rust_future_free_pointer,
            liftFunc: FfiConverterTypeHexEncodedData_lift,
            errorHandler: FfiConverterTypeTransactionError_lift
        )
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeSmartAccount: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SafeSmartAccount

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SafeSmartAccount {
        return SafeSmartAccount(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SafeSmartAccount) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeSmartAccount {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SafeSmartAccount, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccount_lift(_ pointer: UnsafeMutableRawPointer) throws -> SafeSmartAccount {
    return try FfiConverterTypeSafeSmartAccount.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccount_lower(_ value: SafeSmartAccount) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSafeSmartAccount.lower(value)
}






/**
 * A simple demo struct to test tooling functionality like log prefixing and error handling.
 */
public protocol ToolingDemoProtocol: AnyObject, Sendable {
    
    /**
     * Demo: Async operation that showcases automatic tokio runtime configuration
     *
     * This async method demonstrates that the `bedrock_export` macro automatically
     * adds `async_runtime = "tokio"` to the `uniffi::export` attribute when any
     * async functions are detected in the impl block.
     *
     * # Errors
     *
     * Returns `DemoError::Generic` if the async operation fails.
     */
    func demoAsyncOperation(delayMs: UInt64) async throws  -> String
    
    /**
     * Demo: Strongly typed errors for known, structured error cases
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if username is empty.
     * Returns `DemoError::AuthenticationFailed` if credentials are invalid.
     * Returns `DemoError::NetworkTimeout` if user is "slowuser".
     * Returns `DemoError::Generic` if the generic operation fails.
     */
    func demoAuthenticate(username: String, password: String) throws  -> String
    
    /**
     * Demo: Generic errors for complex operations with anyhow error chains
     *
     * # Errors
     *
     * Returns `DemoError::Generic` for various error conditions including
     * empty input, network errors, parse errors, and deep chain errors.
     */
    func demoGenericOperation(input: String) throws  -> String
    
    /**
     * Demo: Mixed usage - structured errors for validation, generic for complex operations
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if operation is empty or unknown.
     * Returns `DemoError::Generic` if the processing operation fails.
     */
    func demoMixedOperation(operation: String, data: String) throws  -> String
    
    /**
     * Returns a simple result for testing.
     */
    func getDemoResult()  -> String
    
    /**
     * Logs a simple message to test log prefixing.
     */
    func logMessage(message: String) 
    
    /**
     * Logs messages at different levels to test log prefixing.
     */
    func testLogLevels() 
    
}
/**
 * A simple demo struct to test tooling functionality like log prefixing and error handling.
 */
open class ToolingDemo: ToolingDemoProtocol, @unchecked Sendable {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_bedrock_fn_clone_toolingdemo(self.pointer, $0) }
    }
    /**
     * Creates a new tooling demo instance.
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_bedrock_fn_constructor_toolingdemo_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_bedrock_fn_free_toolingdemo(pointer, $0) }
    }

    

    
    /**
     * Demo: Async operation that showcases automatic tokio runtime configuration
     *
     * This async method demonstrates that the `bedrock_export` macro automatically
     * adds `async_runtime = "tokio"` to the `uniffi::export` attribute when any
     * async functions are detected in the impl block.
     *
     * # Errors
     *
     * Returns `DemoError::Generic` if the async operation fails.
     */
open func demoAsyncOperation(delayMs: UInt64)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_bedrock_fn_method_toolingdemo_demo_async_operation(
                    self.uniffiClonePointer(),
                    FfiConverterUInt64.lower(delayMs)
                )
            },
            pollFunc: ffi_bedrock_rust_future_poll_rust_buffer,
            completeFunc: ffi_bedrock_rust_future_complete_rust_buffer,
            freeFunc: ffi_bedrock_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeDemoError_lift
        )
}
    
    /**
     * Demo: Strongly typed errors for known, structured error cases
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if username is empty.
     * Returns `DemoError::AuthenticationFailed` if credentials are invalid.
     * Returns `DemoError::NetworkTimeout` if user is "slowuser".
     * Returns `DemoError::Generic` if the generic operation fails.
     */
open func demoAuthenticate(username: String, password: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_authenticate(self.uniffiClonePointer(),
        FfiConverterString.lower(username),
        FfiConverterString.lower(password),$0
    )
})
}
    
    /**
     * Demo: Generic errors for complex operations with anyhow error chains
     *
     * # Errors
     *
     * Returns `DemoError::Generic` for various error conditions including
     * empty input, network errors, parse errors, and deep chain errors.
     */
open func demoGenericOperation(input: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_generic_operation(self.uniffiClonePointer(),
        FfiConverterString.lower(input),$0
    )
})
}
    
    /**
     * Demo: Mixed usage - structured errors for validation, generic for complex operations
     *
     * # Errors
     *
     * Returns `DemoError::InvalidInput` if operation is empty or unknown.
     * Returns `DemoError::Generic` if the processing operation fails.
     */
open func demoMixedOperation(operation: String, data: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeDemoError_lift) {
    uniffi_bedrock_fn_method_toolingdemo_demo_mixed_operation(self.uniffiClonePointer(),
        FfiConverterString.lower(operation),
        FfiConverterString.lower(data),$0
    )
})
}
    
    /**
     * Returns a simple result for testing.
     */
open func getDemoResult() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_get_demo_result(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Logs a simple message to test log prefixing.
     */
open func logMessage(message: String)  {try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_log_message(self.uniffiClonePointer(),
        FfiConverterString.lower(message),$0
    )
}
}
    
    /**
     * Logs messages at different levels to test log prefixing.
     */
open func testLogLevels()  {try! rustCall() {
    uniffi_bedrock_fn_method_toolingdemo_test_log_levels(self.uniffiClonePointer(),$0
    )
}
}
    

}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeToolingDemo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ToolingDemo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ToolingDemo {
        return ToolingDemo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ToolingDemo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ToolingDemo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ToolingDemo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToolingDemo_lift(_ pointer: UnsafeMutableRawPointer) throws -> ToolingDemo {
    return try FfiConverterTypeToolingDemo.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeToolingDemo_lower(_ value: ToolingDemo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeToolingDemo.lower(value)
}




/**
 * Result of re-encrypting the backup keypair with a new factor secret.
 */
public struct AddNewFactorResult {
    /**
     * The re-encrypted backup keypair that can be used to decrypt the backup data. The keypair itself
     * is encrypted with the new factor secret. Hex encoded.
     */
    public var encryptedBackupKeypairWithNewFactor: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The re-encrypted backup keypair that can be used to decrypt the backup data. The keypair itself
         * is encrypted with the new factor secret. Hex encoded.
         */encryptedBackupKeypairWithNewFactor: String) {
        self.encryptedBackupKeypairWithNewFactor = encryptedBackupKeypairWithNewFactor
    }
}

#if compiler(>=6)
extension AddNewFactorResult: Sendable {}
#endif


extension AddNewFactorResult: Equatable, Hashable {
    public static func ==(lhs: AddNewFactorResult, rhs: AddNewFactorResult) -> Bool {
        if lhs.encryptedBackupKeypairWithNewFactor != rhs.encryptedBackupKeypairWithNewFactor {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(encryptedBackupKeypairWithNewFactor)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAddNewFactorResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AddNewFactorResult {
        return
            try AddNewFactorResult(
                encryptedBackupKeypairWithNewFactor: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AddNewFactorResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.encryptedBackupKeypairWithNewFactor, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddNewFactorResult_lift(_ buf: RustBuffer) throws -> AddNewFactorResult {
    return try FfiConverterTypeAddNewFactorResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAddNewFactorResult_lower(_ value: AddNewFactorResult) -> RustBuffer {
    return FfiConverterTypeAddNewFactorResult.lower(value)
}


/**
 * Result of creating a new sealed backup for a user.
 */
public struct CreatedBackup {
    /**
     * The backup data, encrypted with the backup keypair.
     */
    public var sealedBackupData: Data
    /**
     * The encrypted backup keypair. This value is encrypted with some factor secret
     * (e.g. PRF, Turnkey, iCloud Keychain). Hex encoded.
     */
    public var encryptedBackupKeypair: String
    /**
     * The public key of backup keypair that can be used to re-encrypt the backup data. Hex encoded.
     */
    public var backupKeypairPublicKey: String
    /**
     * The manifest hash representing the current backup state. Hex-encoded, 32-byte Blake3 hash.
     */
    public var manifestHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The backup data, encrypted with the backup keypair.
         */sealedBackupData: Data, 
        /**
         * The encrypted backup keypair. This value is encrypted with some factor secret
         * (e.g. PRF, Turnkey, iCloud Keychain). Hex encoded.
         */encryptedBackupKeypair: String, 
        /**
         * The public key of backup keypair that can be used to re-encrypt the backup data. Hex encoded.
         */backupKeypairPublicKey: String, 
        /**
         * The manifest hash representing the current backup state. Hex-encoded, 32-byte Blake3 hash.
         */manifestHash: String) {
        self.sealedBackupData = sealedBackupData
        self.encryptedBackupKeypair = encryptedBackupKeypair
        self.backupKeypairPublicKey = backupKeypairPublicKey
        self.manifestHash = manifestHash
    }
}

#if compiler(>=6)
extension CreatedBackup: Sendable {}
#endif


extension CreatedBackup: Equatable, Hashable {
    public static func ==(lhs: CreatedBackup, rhs: CreatedBackup) -> Bool {
        if lhs.sealedBackupData != rhs.sealedBackupData {
            return false
        }
        if lhs.encryptedBackupKeypair != rhs.encryptedBackupKeypair {
            return false
        }
        if lhs.backupKeypairPublicKey != rhs.backupKeypairPublicKey {
            return false
        }
        if lhs.manifestHash != rhs.manifestHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sealedBackupData)
        hasher.combine(encryptedBackupKeypair)
        hasher.combine(backupKeypairPublicKey)
        hasher.combine(manifestHash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreatedBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreatedBackup {
        return
            try CreatedBackup(
                sealedBackupData: FfiConverterData.read(from: &buf), 
                encryptedBackupKeypair: FfiConverterString.read(from: &buf), 
                backupKeypairPublicKey: FfiConverterString.read(from: &buf), 
                manifestHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: CreatedBackup, into buf: inout [UInt8]) {
        FfiConverterData.write(value.sealedBackupData, into: &buf)
        FfiConverterString.write(value.encryptedBackupKeypair, into: &buf)
        FfiConverterString.write(value.backupKeypairPublicKey, into: &buf)
        FfiConverterString.write(value.manifestHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreatedBackup_lift(_ buf: RustBuffer) throws -> CreatedBackup {
    return try FfiConverterTypeCreatedBackup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreatedBackup_lower(_ value: CreatedBackup) -> RustBuffer {
    return FfiConverterTypeCreatedBackup.lower(value)
}


/**
 * Result of decrypting a sealed backup.
 */
public struct DecryptedBackup {
    /**
     * The JSON-encoded root key. Exposed to foreign code to store securely.
     *
     * TODO: Secure memory pointers.
     */
    public var rootKeyJson: String
    /**
     * The public key of the backup keypair that was used to encrypt the backup. Client will need
     * to save it to re-encrypt future backup updates. Hex encoded.
     */
    public var backupKeypairPublicKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The JSON-encoded root key. Exposed to foreign code to store securely.
         *
         * TODO: Secure memory pointers.
         */rootKeyJson: String, 
        /**
         * The public key of the backup keypair that was used to encrypt the backup. Client will need
         * to save it to re-encrypt future backup updates. Hex encoded.
         */backupKeypairPublicKey: String) {
        self.rootKeyJson = rootKeyJson
        self.backupKeypairPublicKey = backupKeypairPublicKey
    }
}

#if compiler(>=6)
extension DecryptedBackup: Sendable {}
#endif


extension DecryptedBackup: Equatable, Hashable {
    public static func ==(lhs: DecryptedBackup, rhs: DecryptedBackup) -> Bool {
        if lhs.rootKeyJson != rhs.rootKeyJson {
            return false
        }
        if lhs.backupKeypairPublicKey != rhs.backupKeypairPublicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rootKeyJson)
        hasher.combine(backupKeypairPublicKey)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDecryptedBackup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DecryptedBackup {
        return
            try DecryptedBackup(
                rootKeyJson: FfiConverterString.read(from: &buf), 
                backupKeypairPublicKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DecryptedBackup, into buf: inout [UInt8]) {
        FfiConverterString.write(value.rootKeyJson, into: &buf)
        FfiConverterString.write(value.backupKeypairPublicKey, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecryptedBackup_lift(_ buf: RustBuffer) throws -> DecryptedBackup {
    return try FfiConverterTypeDecryptedBackup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDecryptedBackup_lower(_ value: DecryptedBackup) -> RustBuffer {
    return FfiConverterTypeDecryptedBackup.lower(value)
}


/**
 * Simple name/value HTTP header pair for passing additional headers
 */
public struct HttpHeader {
    /**
     * Header name
     */
    public var name: String
    /**
     * Header value
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Header name
         */name: String, 
        /**
         * Header value
         */value: String) {
        self.name = name
        self.value = value
    }
}

#if compiler(>=6)
extension HttpHeader: Sendable {}
#endif


extension HttpHeader: Equatable, Hashable {
    public static func ==(lhs: HttpHeader, rhs: HttpHeader) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpHeader: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpHeader {
        return
            try HttpHeader(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpHeader, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpHeader_lift(_ buf: RustBuffer) throws -> HttpHeader {
    return try FfiConverterTypeHttpHeader.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpHeader_lower(_ value: HttpHeader) -> RustBuffer {
    return FfiConverterTypeHttpHeader.lower(value)
}


/**
 * Response body for retrieve metadata call.
 *
 * # Notes
 * Only the required attributes are returned to Bedrock (avoids additional memory allocations)
 */
public struct RetrieveMetadataResponsePayload {
    /**
     * The hex-encoded manifest hash.
     */
    public var manifestHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The hex-encoded manifest hash.
         */manifestHash: String) {
        self.manifestHash = manifestHash
    }
}

#if compiler(>=6)
extension RetrieveMetadataResponsePayload: Sendable {}
#endif


extension RetrieveMetadataResponsePayload: Equatable, Hashable {
    public static func ==(lhs: RetrieveMetadataResponsePayload, rhs: RetrieveMetadataResponsePayload) -> Bool {
        if lhs.manifestHash != rhs.manifestHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(manifestHash)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRetrieveMetadataResponsePayload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetrieveMetadataResponsePayload {
        return
            try RetrieveMetadataResponsePayload(
                manifestHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: RetrieveMetadataResponsePayload, into buf: inout [UInt8]) {
        FfiConverterString.write(value.manifestHash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetrieveMetadataResponsePayload_lift(_ buf: RustBuffer) throws -> RetrieveMetadataResponsePayload {
    return try FfiConverterTypeRetrieveMetadataResponsePayload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRetrieveMetadataResponsePayload_lower(_ value: RetrieveMetadataResponsePayload) -> RustBuffer {
    return FfiConverterTypeRetrieveMetadataResponsePayload.lower(value)
}


/**
 * For Swift & Kotlin usage only.
 *
 * Represents a Safe Smart Account transaction which can be initialized by foreign code to be then signed.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account/blob/v1.4.1/contracts/Safe.sol#L139>
 */
public struct SafeTransaction {
    /**
     * Destination address of the Safe transaction.
     * Solidity type: `address`
     */
    public var to: String
    /**
     * Ether value of the Safe transaction.
     * Solidity type: `uint256`
     */
    public var value: String
    /**
     * Data payload of the Safe transaction.
     * Solidity type: `bytes`
     */
    public var data: String
    /**
     * The type of operation to perform on behalf of the Safe Smart Account.
     * Solidity type: `uint8`
     */
    public var operation: SafeOperation
    /**
     * The maximum gas that can be used for the Safe transaction.
     * Solidity type: `uint256`
     */
    public var safeTxGas: String
    /**
     * Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)
     * Solidity type: `uint256`
     */
    public var baseGas: String
    /**
     * Gas price that should be used for the payment calculation.
     * Solidity type: `uint256`
     */
    public var gasPrice: String
    /**
     * Token address (or 0 if ETH) that is used for the payment.
     * Solidity type: `address`
     */
    public var gasToken: String
    /**
     * Address of receiver of gas payment (or 0 if tx.origin).
     * Solidity type: `address`
     */
    public var refundReceiver: String
    /**
     * The sequential nonce of the transaction. Used to prevent replay attacks.
     * Solidity type: `uint256`
     */
    public var nonce: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Destination address of the Safe transaction.
         * Solidity type: `address`
         */to: String, 
        /**
         * Ether value of the Safe transaction.
         * Solidity type: `uint256`
         */value: String, 
        /**
         * Data payload of the Safe transaction.
         * Solidity type: `bytes`
         */data: String, 
        /**
         * The type of operation to perform on behalf of the Safe Smart Account.
         * Solidity type: `uint8`
         */operation: SafeOperation, 
        /**
         * The maximum gas that can be used for the Safe transaction.
         * Solidity type: `uint256`
         */safeTxGas: String, 
        /**
         * Gas costs that are independent of the transaction execution (e.g. base transaction fee, signature check, payment of the refund)
         * Solidity type: `uint256`
         */baseGas: String, 
        /**
         * Gas price that should be used for the payment calculation.
         * Solidity type: `uint256`
         */gasPrice: String, 
        /**
         * Token address (or 0 if ETH) that is used for the payment.
         * Solidity type: `address`
         */gasToken: String, 
        /**
         * Address of receiver of gas payment (or 0 if tx.origin).
         * Solidity type: `address`
         */refundReceiver: String, 
        /**
         * The sequential nonce of the transaction. Used to prevent replay attacks.
         * Solidity type: `uint256`
         */nonce: String) {
        self.to = to
        self.value = value
        self.data = data
        self.operation = operation
        self.safeTxGas = safeTxGas
        self.baseGas = baseGas
        self.gasPrice = gasPrice
        self.gasToken = gasToken
        self.refundReceiver = refundReceiver
        self.nonce = nonce
    }
}

#if compiler(>=6)
extension SafeTransaction: Sendable {}
#endif


extension SafeTransaction: Equatable, Hashable {
    public static func ==(lhs: SafeTransaction, rhs: SafeTransaction) -> Bool {
        if lhs.to != rhs.to {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        if lhs.operation != rhs.operation {
            return false
        }
        if lhs.safeTxGas != rhs.safeTxGas {
            return false
        }
        if lhs.baseGas != rhs.baseGas {
            return false
        }
        if lhs.gasPrice != rhs.gasPrice {
            return false
        }
        if lhs.gasToken != rhs.gasToken {
            return false
        }
        if lhs.refundReceiver != rhs.refundReceiver {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(to)
        hasher.combine(value)
        hasher.combine(data)
        hasher.combine(operation)
        hasher.combine(safeTxGas)
        hasher.combine(baseGas)
        hasher.combine(gasPrice)
        hasher.combine(gasToken)
        hasher.combine(refundReceiver)
        hasher.combine(nonce)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeTransaction {
        return
            try SafeTransaction(
                to: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                data: FfiConverterString.read(from: &buf), 
                operation: FfiConverterTypeSafeOperation.read(from: &buf), 
                safeTxGas: FfiConverterString.read(from: &buf), 
                baseGas: FfiConverterString.read(from: &buf), 
                gasPrice: FfiConverterString.read(from: &buf), 
                gasToken: FfiConverterString.read(from: &buf), 
                refundReceiver: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SafeTransaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.to, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterString.write(value.data, into: &buf)
        FfiConverterTypeSafeOperation.write(value.operation, into: &buf)
        FfiConverterString.write(value.safeTxGas, into: &buf)
        FfiConverterString.write(value.baseGas, into: &buf)
        FfiConverterString.write(value.gasPrice, into: &buf)
        FfiConverterString.write(value.gasToken, into: &buf)
        FfiConverterString.write(value.refundReceiver, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeTransaction_lift(_ buf: RustBuffer) throws -> SafeTransaction {
    return try FfiConverterTypeSafeTransaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeTransaction_lower(_ value: SafeTransaction) -> RustBuffer {
    return FfiConverterTypeSafeTransaction.lower(value)
}


/**
 * Request body for `/v1/sync` (i.e. backup upload)
 *
 * Reference: <https://github.com/worldcoin/backup-service/blob/main/src/routes/sync_backup.rs>
 *
 * # Notes
 * `authorization` and `challenge_token` are skipped because they are handled by the Native App.
 */
public struct SyncSubmitRequest {
    /**
     * Hex-encoded current manifest hash (client state before the update).
     */
    public var currentManifestHash: String
    /**
     * Hex-encoded new manifest hash (client state after applying the update).
     */
    public var newManifestHash: String
    /**
     * Sealed backup bytes to upload.
     */
    public var sealedBackup: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded current manifest hash (client state before the update).
         */currentManifestHash: String, 
        /**
         * Hex-encoded new manifest hash (client state after applying the update).
         */newManifestHash: String, 
        /**
         * Sealed backup bytes to upload.
         */sealedBackup: Data) {
        self.currentManifestHash = currentManifestHash
        self.newManifestHash = newManifestHash
        self.sealedBackup = sealedBackup
    }
}

#if compiler(>=6)
extension SyncSubmitRequest: Sendable {}
#endif


extension SyncSubmitRequest: Equatable, Hashable {
    public static func ==(lhs: SyncSubmitRequest, rhs: SyncSubmitRequest) -> Bool {
        if lhs.currentManifestHash != rhs.currentManifestHash {
            return false
        }
        if lhs.newManifestHash != rhs.newManifestHash {
            return false
        }
        if lhs.sealedBackup != rhs.sealedBackup {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(currentManifestHash)
        hasher.combine(newManifestHash)
        hasher.combine(sealedBackup)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncSubmitRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncSubmitRequest {
        return
            try SyncSubmitRequest(
                currentManifestHash: FfiConverterString.read(from: &buf), 
                newManifestHash: FfiConverterString.read(from: &buf), 
                sealedBackup: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: SyncSubmitRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.currentManifestHash, into: &buf)
        FfiConverterString.write(value.newManifestHash, into: &buf)
        FfiConverterData.write(value.sealedBackup, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncSubmitRequest_lift(_ buf: RustBuffer) throws -> SyncSubmitRequest {
    return try FfiConverterTypeSyncSubmitRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncSubmitRequest_lower(_ value: SyncSubmitRequest) -> RustBuffer {
    return FfiConverterTypeSyncSubmitRequest.lower(value)
}


/**
 * For Swift & Kotlin usage only.
 *
 * The signed permit message for a single token transfer.
 *
 * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/interfaces/ISignatureTransfer.sol#L30>
 */
public struct UnparsedPermitTransferFrom {
    /**
     * The token and amount details for a transfer signed in the permit transfer signature
     */
    public var permitted: UnparsedTokenPermissions
    /**
     * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/libraries/PermitHash.sol#L62>
     * Solidity type: `address`
     */
    public var spender: String
    /**
     * A unique value for every token owner's signature to prevent replays
     * Solidity type: `uint256`
     */
    public var nonce: String
    /**
     * Deadline (timestamp) after which the signature is no longer valid
     * Solidity type: `uint256`
     */
    public var deadline: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The token and amount details for a transfer signed in the permit transfer signature
         */permitted: UnparsedTokenPermissions, 
        /**
         * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/libraries/PermitHash.sol#L62>
         * Solidity type: `address`
         */spender: String, 
        /**
         * A unique value for every token owner's signature to prevent replays
         * Solidity type: `uint256`
         */nonce: String, 
        /**
         * Deadline (timestamp) after which the signature is no longer valid
         * Solidity type: `uint256`
         */deadline: String) {
        self.permitted = permitted
        self.spender = spender
        self.nonce = nonce
        self.deadline = deadline
    }
}

#if compiler(>=6)
extension UnparsedPermitTransferFrom: Sendable {}
#endif


extension UnparsedPermitTransferFrom: Equatable, Hashable {
    public static func ==(lhs: UnparsedPermitTransferFrom, rhs: UnparsedPermitTransferFrom) -> Bool {
        if lhs.permitted != rhs.permitted {
            return false
        }
        if lhs.spender != rhs.spender {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.deadline != rhs.deadline {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(permitted)
        hasher.combine(spender)
        hasher.combine(nonce)
        hasher.combine(deadline)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnparsedPermitTransferFrom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnparsedPermitTransferFrom {
        return
            try UnparsedPermitTransferFrom(
                permitted: FfiConverterTypeUnparsedTokenPermissions.read(from: &buf), 
                spender: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf), 
                deadline: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnparsedPermitTransferFrom, into buf: inout [UInt8]) {
        FfiConverterTypeUnparsedTokenPermissions.write(value.permitted, into: &buf)
        FfiConverterString.write(value.spender, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
        FfiConverterString.write(value.deadline, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedPermitTransferFrom_lift(_ buf: RustBuffer) throws -> UnparsedPermitTransferFrom {
    return try FfiConverterTypeUnparsedPermitTransferFrom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedPermitTransferFrom_lower(_ value: UnparsedPermitTransferFrom) -> RustBuffer {
    return FfiConverterTypeUnparsedPermitTransferFrom.lower(value)
}


/**
 * For Swift & Kotlin usage only.
 *
 * The token and amount details for a transfer signed in the permit transfer signature.
 *
 * Reference: <https://github.com/Uniswap/permit2/blob/cc56ad0f3439c502c246fc5cfcc3db92bb8b7219/src/interfaces/ISignatureTransfer.sol#L22>
 */
public struct UnparsedTokenPermissions {
    /**
     * Solidity type: `address`
     */
    public var token: String
    /**
     * Solidity type: `uint256`
     */
    public var amount: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Solidity type: `address`
         */token: String, 
        /**
         * Solidity type: `uint256`
         */amount: String) {
        self.token = token
        self.amount = amount
    }
}

#if compiler(>=6)
extension UnparsedTokenPermissions: Sendable {}
#endif


extension UnparsedTokenPermissions: Equatable, Hashable {
    public static func ==(lhs: UnparsedTokenPermissions, rhs: UnparsedTokenPermissions) -> Bool {
        if lhs.token != rhs.token {
            return false
        }
        if lhs.amount != rhs.amount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(token)
        hasher.combine(amount)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnparsedTokenPermissions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnparsedTokenPermissions {
        return
            try UnparsedTokenPermissions(
                token: FfiConverterString.read(from: &buf), 
                amount: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UnparsedTokenPermissions, into buf: inout [UInt8]) {
        FfiConverterString.write(value.token, into: &buf)
        FfiConverterString.write(value.amount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedTokenPermissions_lift(_ buf: RustBuffer) throws -> UnparsedTokenPermissions {
    return try FfiConverterTypeUnparsedTokenPermissions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedTokenPermissions_lower(_ value: UnparsedTokenPermissions) -> RustBuffer {
    return FfiConverterTypeUnparsedTokenPermissions.lower(value)
}


/**
 * A pseudo-transaction object for EIP-4337. Used to execute transactions through the Safe Smart Account.
 *
 * This object is expected to be initialized from foreign languages.
 *
 * Reference: <https://www.erc4337.io/docs/understanding-ERC-4337/user-operation>
 *
 * Note the types of this struct are types that can be lifted from foreign languages to be then parsed and validated.
 */
public struct UnparsedUserOperation {
    /**
     * The address of the smart contract account (Solidity type: `address`)
     */
    public var sender: String
    /**
     * Anti-replay protection; also used as the salt for first-time account creation (Solidity type: `uint256`)
     */
    public var nonce: String
    /**
     * Data that's passed to the sender for execution (Solidity type: `bytes`)
     */
    public var callData: String
    /**
     * Gas limit for execution phase (Solidity type: `uint128`)
     */
    public var callGasLimit: String
    /**
     * Gas limit for verification phase (Solidity type: `uint128`)
     */
    public var verificationGasLimit: String
    /**
     * Gas to compensate the bundler (Solidity type: `uint128`)
     */
    public var preVerificationGas: String
    /**
     * Maximum fee per gas (similar to [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)'s `max_fee_per_gas`) (Solidity type: `uint128`)
     */
    public var maxFeePerGas: String
    /**
     * Maximum priority fee per gas (Solidity type: `uint128`)
     */
    public var maxPriorityFeePerGas: String
    /**
     * Paymaster contact address (Solidity type: `address`)
     */
    public var paymaster: String?
    /**
     * Paymaster verification gas limit (Solidity type: `uint128`)
     */
    public var paymasterVerificationGasLimit: String
    /**
     * Paymaster post-operation gas limit (Solidity type: `uint128`)
     */
    public var paymasterPostOpGasLimit: String
    /**
     * Paymaster additional data for verification (Solidity type: `bytes`)
     */
    public var paymasterData: String?
    /**
     * Used to validate a `UserOperation` along with the nonce during verification (Solidity type: `bytes`)
     */
    public var signature: String
    /**
     * Factory address (Solidity type: `address`)
     */
    public var factory: String?
    /**
     * Factory data (Solidity type: `bytes`)
     */
    public var factoryData: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The address of the smart contract account (Solidity type: `address`)
         */sender: String, 
        /**
         * Anti-replay protection; also used as the salt for first-time account creation (Solidity type: `uint256`)
         */nonce: String, 
        /**
         * Data that's passed to the sender for execution (Solidity type: `bytes`)
         */callData: String, 
        /**
         * Gas limit for execution phase (Solidity type: `uint128`)
         */callGasLimit: String, 
        /**
         * Gas limit for verification phase (Solidity type: `uint128`)
         */verificationGasLimit: String, 
        /**
         * Gas to compensate the bundler (Solidity type: `uint128`)
         */preVerificationGas: String, 
        /**
         * Maximum fee per gas (similar to [EIP-1559](https://eips.ethereum.org/EIPS/eip-1559)'s `max_fee_per_gas`) (Solidity type: `uint128`)
         */maxFeePerGas: String, 
        /**
         * Maximum priority fee per gas (Solidity type: `uint128`)
         */maxPriorityFeePerGas: String, 
        /**
         * Paymaster contact address (Solidity type: `address`)
         */paymaster: String?, 
        /**
         * Paymaster verification gas limit (Solidity type: `uint128`)
         */paymasterVerificationGasLimit: String, 
        /**
         * Paymaster post-operation gas limit (Solidity type: `uint128`)
         */paymasterPostOpGasLimit: String, 
        /**
         * Paymaster additional data for verification (Solidity type: `bytes`)
         */paymasterData: String?, 
        /**
         * Used to validate a `UserOperation` along with the nonce during verification (Solidity type: `bytes`)
         */signature: String, 
        /**
         * Factory address (Solidity type: `address`)
         */factory: String?, 
        /**
         * Factory data (Solidity type: `bytes`)
         */factoryData: String?) {
        self.sender = sender
        self.nonce = nonce
        self.callData = callData
        self.callGasLimit = callGasLimit
        self.verificationGasLimit = verificationGasLimit
        self.preVerificationGas = preVerificationGas
        self.maxFeePerGas = maxFeePerGas
        self.maxPriorityFeePerGas = maxPriorityFeePerGas
        self.paymaster = paymaster
        self.paymasterVerificationGasLimit = paymasterVerificationGasLimit
        self.paymasterPostOpGasLimit = paymasterPostOpGasLimit
        self.paymasterData = paymasterData
        self.signature = signature
        self.factory = factory
        self.factoryData = factoryData
    }
}

#if compiler(>=6)
extension UnparsedUserOperation: Sendable {}
#endif


extension UnparsedUserOperation: Equatable, Hashable {
    public static func ==(lhs: UnparsedUserOperation, rhs: UnparsedUserOperation) -> Bool {
        if lhs.sender != rhs.sender {
            return false
        }
        if lhs.nonce != rhs.nonce {
            return false
        }
        if lhs.callData != rhs.callData {
            return false
        }
        if lhs.callGasLimit != rhs.callGasLimit {
            return false
        }
        if lhs.verificationGasLimit != rhs.verificationGasLimit {
            return false
        }
        if lhs.preVerificationGas != rhs.preVerificationGas {
            return false
        }
        if lhs.maxFeePerGas != rhs.maxFeePerGas {
            return false
        }
        if lhs.maxPriorityFeePerGas != rhs.maxPriorityFeePerGas {
            return false
        }
        if lhs.paymaster != rhs.paymaster {
            return false
        }
        if lhs.paymasterVerificationGasLimit != rhs.paymasterVerificationGasLimit {
            return false
        }
        if lhs.paymasterPostOpGasLimit != rhs.paymasterPostOpGasLimit {
            return false
        }
        if lhs.paymasterData != rhs.paymasterData {
            return false
        }
        if lhs.signature != rhs.signature {
            return false
        }
        if lhs.factory != rhs.factory {
            return false
        }
        if lhs.factoryData != rhs.factoryData {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(sender)
        hasher.combine(nonce)
        hasher.combine(callData)
        hasher.combine(callGasLimit)
        hasher.combine(verificationGasLimit)
        hasher.combine(preVerificationGas)
        hasher.combine(maxFeePerGas)
        hasher.combine(maxPriorityFeePerGas)
        hasher.combine(paymaster)
        hasher.combine(paymasterVerificationGasLimit)
        hasher.combine(paymasterPostOpGasLimit)
        hasher.combine(paymasterData)
        hasher.combine(signature)
        hasher.combine(factory)
        hasher.combine(factoryData)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnparsedUserOperation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnparsedUserOperation {
        return
            try UnparsedUserOperation(
                sender: FfiConverterString.read(from: &buf), 
                nonce: FfiConverterString.read(from: &buf), 
                callData: FfiConverterString.read(from: &buf), 
                callGasLimit: FfiConverterString.read(from: &buf), 
                verificationGasLimit: FfiConverterString.read(from: &buf), 
                preVerificationGas: FfiConverterString.read(from: &buf), 
                maxFeePerGas: FfiConverterString.read(from: &buf), 
                maxPriorityFeePerGas: FfiConverterString.read(from: &buf), 
                paymaster: FfiConverterOptionString.read(from: &buf), 
                paymasterVerificationGasLimit: FfiConverterString.read(from: &buf), 
                paymasterPostOpGasLimit: FfiConverterString.read(from: &buf), 
                paymasterData: FfiConverterOptionString.read(from: &buf), 
                signature: FfiConverterString.read(from: &buf), 
                factory: FfiConverterOptionString.read(from: &buf), 
                factoryData: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UnparsedUserOperation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.sender, into: &buf)
        FfiConverterString.write(value.nonce, into: &buf)
        FfiConverterString.write(value.callData, into: &buf)
        FfiConverterString.write(value.callGasLimit, into: &buf)
        FfiConverterString.write(value.verificationGasLimit, into: &buf)
        FfiConverterString.write(value.preVerificationGas, into: &buf)
        FfiConverterString.write(value.maxFeePerGas, into: &buf)
        FfiConverterString.write(value.maxPriorityFeePerGas, into: &buf)
        FfiConverterOptionString.write(value.paymaster, into: &buf)
        FfiConverterString.write(value.paymasterVerificationGasLimit, into: &buf)
        FfiConverterString.write(value.paymasterPostOpGasLimit, into: &buf)
        FfiConverterOptionString.write(value.paymasterData, into: &buf)
        FfiConverterString.write(value.signature, into: &buf)
        FfiConverterOptionString.write(value.factory, into: &buf)
        FfiConverterOptionString.write(value.factoryData, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedUserOperation_lift(_ buf: RustBuffer) throws -> UnparsedUserOperation {
    return try FfiConverterTypeUnparsedUserOperation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnparsedUserOperation_lower(_ value: UnparsedUserOperation) -> RustBuffer {
    return FfiConverterTypeUnparsedUserOperation.lower(value)
}


/**
 * Verified attestation data from the enclave.
 */
public struct VerifiedAttestation {
    /**
     * The base64 encoded public key of the enclave
     */
    public var enclavePublicKey: String
    /**
     * The timestamp of the attestation
     */
    public var timestamp: UInt64
    /**
     * The module ID of the enclave
     */
    public var moduleId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The base64 encoded public key of the enclave
         */enclavePublicKey: String, 
        /**
         * The timestamp of the attestation
         */timestamp: UInt64, 
        /**
         * The module ID of the enclave
         */moduleId: String) {
        self.enclavePublicKey = enclavePublicKey
        self.timestamp = timestamp
        self.moduleId = moduleId
    }
}

#if compiler(>=6)
extension VerifiedAttestation: Sendable {}
#endif


extension VerifiedAttestation: Equatable, Hashable {
    public static func ==(lhs: VerifiedAttestation, rhs: VerifiedAttestation) -> Bool {
        if lhs.enclavePublicKey != rhs.enclavePublicKey {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        if lhs.moduleId != rhs.moduleId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(enclavePublicKey)
        hasher.combine(timestamp)
        hasher.combine(moduleId)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiedAttestation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiedAttestation {
        return
            try VerifiedAttestation(
                enclavePublicKey: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterUInt64.read(from: &buf), 
                moduleId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiedAttestation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.enclavePublicKey, into: &buf)
        FfiConverterUInt64.write(value.timestamp, into: &buf)
        FfiConverterString.write(value.moduleId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiedAttestation_lift(_ buf: RustBuffer) throws -> VerifiedAttestation {
    return try FfiConverterTypeVerifiedAttestation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiedAttestation_lower(_ value: VerifiedAttestation) -> RustBuffer {
    return FfiConverterTypeVerifiedAttestation.lower(value)
}


/**
 * Verified attestation with ciphertext
 */
public struct VerifiedAttestationWithCiphertext {
    /**
     * The verified attestation
     */
    public var verifiedAttestation: VerifiedAttestation
    /**
     * The base64 encoded ciphertext
     */
    public var ciphertextBase64: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The verified attestation
         */verifiedAttestation: VerifiedAttestation, 
        /**
         * The base64 encoded ciphertext
         */ciphertextBase64: String) {
        self.verifiedAttestation = verifiedAttestation
        self.ciphertextBase64 = ciphertextBase64
    }
}

#if compiler(>=6)
extension VerifiedAttestationWithCiphertext: Sendable {}
#endif


extension VerifiedAttestationWithCiphertext: Equatable, Hashable {
    public static func ==(lhs: VerifiedAttestationWithCiphertext, rhs: VerifiedAttestationWithCiphertext) -> Bool {
        if lhs.verifiedAttestation != rhs.verifiedAttestation {
            return false
        }
        if lhs.ciphertextBase64 != rhs.ciphertextBase64 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(verifiedAttestation)
        hasher.combine(ciphertextBase64)
    }
}



#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerifiedAttestationWithCiphertext: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerifiedAttestationWithCiphertext {
        return
            try VerifiedAttestationWithCiphertext(
                verifiedAttestation: FfiConverterTypeVerifiedAttestation.read(from: &buf), 
                ciphertextBase64: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: VerifiedAttestationWithCiphertext, into buf: inout [UInt8]) {
        FfiConverterTypeVerifiedAttestation.write(value.verifiedAttestation, into: &buf)
        FfiConverterString.write(value.ciphertextBase64, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiedAttestationWithCiphertext_lift(_ buf: RustBuffer) throws -> VerifiedAttestationWithCiphertext {
    return try FfiConverterTypeVerifiedAttestationWithCiphertext.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerifiedAttestationWithCiphertext_lower(_ value: VerifiedAttestationWithCiphertext) -> RustBuffer {
    return FfiConverterTypeVerifiedAttestationWithCiphertext.lower(value)
}


/**
 * Errors that can occur when working with backups and manifests.
 */
public enum BackupError: Swift.Error {

    
    
    /**
     * Failed to decode factor secret as hex.
     */
    case DecodeFactorSecretError(message: String)
    
    /**
     * Factor secret is not the expected length.
     */
    case InvalidFactorSecretLengthError(message: String)
    
    /**
     * Failed to decode backup keypair bytes.
     */
    case DecodeBackupKeypairError(message: String)
    
    /**
     * Failed to decrypt backup keypair with factor secret.
     */
    case DecryptBackupKeypairError(message: String)
    
    /**
     * Failed to decrypt sealed backup data with backup keypair.
     */
    case DecryptBackupError(message: String)
    
    /**
     * Provided sealed backup data is empty or malformed.
     */
    case InvalidSealedBackupError(message: String)
    
    /**
     * Failed to encrypt data using provided key.
     */
    case EncryptBackupError(message: String)
    
    /**
     * IO error while reading/writing backup data.
     */
    case IoError(message: String)
    
    /**
     * Root secret inside backup is invalid.
     */
    case InvalidRootSecretError(message: String)
    
    /**
     * Backup version cannot be detected.
     */
    case VersionNotDetectedError(message: String)
    
    /**
     * Failed to read file name from archive entry.
     */
    case ReadFileNameError(message: String)
    
    /**
     * Failed to encode root secret to JSON.
     */
    case EncodeRootSecretError(message: String)
    
    /**
     * The provided file from a manifest to build the unsealed backup is not valid.
     * The provided file from a manifest to build the unsealed backup is not valid.
     */
    case InvalidFileForBackup(message: String)
    
    /**
     * CBOR encoding error while writing a backup file.
     */
    case EncodeBackupFileError(message: String)
    
    /**
     * CBOR decoding error while reading a backup file.
     */
    case DecodeBackupFileError(message: String)
    
    /**
     * Manifest file not found.
     */
    case ManifestNotFound(message: String)
    
    /**
     * File checksum does not match the expected value.
     */
    case InvalidChecksumError(message: String)
    
    /**
     * Remote manifest head is ahead of local.
     * Native layer should trigger a download/apply of the latest backup before retrying.
     * Remote manifest head is ahead of local; fetch and apply latest backup before retrying.
     */
    case RemoteAheadStaleError(message: String)
    
    /**
     * HTTP error.
     */
    case HttpError(message: String)
    
    /**
     * Backup API not initialized.
     */
    case BackupApiNotInitialized(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupError: FfiConverterRustBuffer {
    typealias SwiftType = BackupError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DecodeFactorSecretError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidFactorSecretLengthError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .DecodeBackupKeypairError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .DecryptBackupKeypairError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .DecryptBackupError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidSealedBackupError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .EncryptBackupError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .IoError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .InvalidRootSecretError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .VersionNotDetectedError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .ReadFileNameError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .EncodeRootSecretError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .InvalidFileForBackup(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .EncodeBackupFileError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .DecodeBackupFileError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .ManifestNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .InvalidChecksumError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .RemoteAheadStaleError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .HttpError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .BackupApiNotInitialized(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .DecodeFactorSecretError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidFactorSecretLengthError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .DecodeBackupKeypairError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .DecryptBackupKeypairError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .DecryptBackupError(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidSealedBackupError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .EncryptBackupError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .IoError(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .InvalidRootSecretError(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .VersionNotDetectedError(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .ReadFileNameError(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .EncodeRootSecretError(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .InvalidFileForBackup(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .EncodeBackupFileError(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .DecodeBackupFileError(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .ManifestNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .InvalidChecksumError(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .RemoteAheadStaleError(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))
        case .HttpError(_ /* message is ignored*/):
            writeInt(&buf, Int32(19))
        case .BackupApiNotInitialized(_ /* message is ignored*/):
            writeInt(&buf, Int32(20))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(21))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(22))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupError_lift(_ buf: RustBuffer) throws -> BackupError {
    return try FfiConverterTypeBackupError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupError_lower(_ value: BackupError) -> RustBuffer {
    return FfiConverterTypeBackupError.lower(value)
}


extension BackupError: Equatable, Hashable {}




extension BackupError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A global identifier that identifies the type of file.
 */

public enum BackupFileDesignator {
    
    /**
     * Orb Personal Custody Package (PCP) or "Orb Credential"
     */
    case orbPkg
    /**
     * Document (NFC) Personal Custody Package (PCP) or "Document Credential"
     */
    case documentPkg
    /**
     * Secure Document (NFC) Personal Custody Package (PCP) or "Secure Document Credential"
     */
    case secureDocumentPkg
}


#if compiler(>=6)
extension BackupFileDesignator: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupFileDesignator: FfiConverterRustBuffer {
    typealias SwiftType = BackupFileDesignator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupFileDesignator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .orbPkg
        
        case 2: return .documentPkg
        
        case 3: return .secureDocumentPkg
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupFileDesignator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .orbPkg:
            writeInt(&buf, Int32(1))
        
        
        case .documentPkg:
            writeInt(&buf, Int32(2))
        
        
        case .secureDocumentPkg:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupFileDesignator_lift(_ buf: RustBuffer) throws -> BackupFileDesignator {
    return try FfiConverterTypeBackupFileDesignator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupFileDesignator_lower(_ value: BackupFileDesignator) -> RustBuffer {
    return FfiConverterTypeBackupFileDesignator.lower(value)
}


extension BackupFileDesignator: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Represents the environment for Bedrock operations
 */

public enum BedrockEnvironment {
    
    /**
     * Staging environment
     */
    case staging
    /**
     * Production environment
     */
    case production
}


#if compiler(>=6)
extension BedrockEnvironment: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBedrockEnvironment: FfiConverterRustBuffer {
    typealias SwiftType = BedrockEnvironment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BedrockEnvironment {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .staging
        
        case 2: return .production
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BedrockEnvironment, into buf: inout [UInt8]) {
        switch value {
        
        
        case .staging:
            writeInt(&buf, Int32(1))
        
        
        case .production:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockEnvironment_lift(_ buf: RustBuffer) throws -> BedrockEnvironment {
    return try FfiConverterTypeBedrockEnvironment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBedrockEnvironment_lower(_ value: BedrockEnvironment) -> RustBuffer {
    return FfiConverterTypeBedrockEnvironment.lower(value)
}


extension BedrockEnvironment: Equatable, Hashable {}







/**
 * Error type for demonstrating bedrock error handling patterns.
 *
 * The `#[bedrock_error]` macro automatically:
 * - Adds `#[derive(Debug, thiserror::Error, uniffi::Error)]` and `#[uniffi(flat_error)]`
 * - Adds a `Generic { message: String }` variant
 * - Implements `From<anyhow::Error>` for automatic conversion
 * - Provides helper methods for error handling
 */
public enum DemoError: Swift.Error {

    
    
    /**
     * Authentication failed with a specific error code
     */
    case AuthenticationFailed(message: String)
    
    /**
     * Network operation timed out after specified number of seconds
     */
    case NetworkTimeout(message: String)
    
    /**
     * Invalid input was provided with a descriptive message
     */
    case InvalidInput(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDemoError: FfiConverterRustBuffer {
    typealias SwiftType = DemoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DemoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AuthenticationFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NetworkTimeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DemoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AuthenticationFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .NetworkTimeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDemoError_lift(_ buf: RustBuffer) throws -> DemoError {
    return try FfiConverterTypeDemoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDemoError_lower(_ value: DemoError) -> RustBuffer {
    return FfiConverterTypeDemoError.lower(value)
}


extension DemoError: Equatable, Hashable {}




extension DemoError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Represents errors that can occur during enclave attestation verification
 */
public enum EnclaveAttestationError: Swift.Error {

    
    
    /**
     * Failed to parse attestation document
     */
    case AttestationDocumentParseError(message: String)
    
    /**
     * Certificate chain validation failed
     */
    case AttestationChainInvalid(message: String)
    
    /**
     * Signature verification failed
     */
    case AttestationSignatureInvalid(message: String)
    
    /**
     * PCR value did not match the expected value
     */
    case CodeUntrusted(message: String)
    
    /**
     * Attestation timestamp is too old
     */
    case AttestationStale(message: String)
    
    /**
     * Invalid timestamp
     */
    case AttestationInvalidTimestamp(message: String)
    
    /**
     * Invalid enclave public key
     */
    case InvalidEnclavePublicKey(message: String)
    
    /**
     * Failed to encrypt data
     */
    case EncryptionError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnclaveAttestationError: FfiConverterRustBuffer {
    typealias SwiftType = EnclaveAttestationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnclaveAttestationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AttestationDocumentParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .AttestationChainInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .AttestationSignatureInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .CodeUntrusted(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .AttestationStale(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .AttestationInvalidTimestamp(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .InvalidEnclavePublicKey(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .EncryptionError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnclaveAttestationError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .AttestationDocumentParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .AttestationChainInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .AttestationSignatureInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .CodeUntrusted(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .AttestationStale(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .AttestationInvalidTimestamp(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .InvalidEnclavePublicKey(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .EncryptionError(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnclaveAttestationError_lift(_ buf: RustBuffer) throws -> EnclaveAttestationError {
    return try FfiConverterTypeEnclaveAttestationError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnclaveAttestationError_lower(_ value: EnclaveAttestationError) -> RustBuffer {
    return FfiConverterTypeEnclaveAttestationError.lower(value)
}


extension EnclaveAttestationError: Equatable, Hashable {}




extension EnclaveAttestationError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The factor type used to encrypt the backup keypair.
 */

public enum FactorType {
    
    /**
     * Generated using a passkey PRF.
     */
    case prf
    /**
     * Generated randomly and stored in the iCloud keychain.
     */
    case icloudKeychain
    /**
     * Generated randomly and stored in Turnkey.
     */
    case turnkey
}


#if compiler(>=6)
extension FactorType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFactorType: FfiConverterRustBuffer {
    typealias SwiftType = FactorType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FactorType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .prf
        
        case 2: return .icloudKeychain
        
        case 3: return .turnkey
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FactorType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .prf:
            writeInt(&buf, Int32(1))
        
        
        case .icloudKeychain:
            writeInt(&buf, Int32(2))
        
        
        case .turnkey:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorType_lift(_ buf: RustBuffer) throws -> FactorType {
    return try FfiConverterTypeFactorType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFactorType_lower(_ value: FactorType) -> RustBuffer {
    return FfiConverterTypeFactorType.lower(value)
}


extension FactorType: Equatable, Hashable {}







/**
 * Errors that can occur during filesystem operations
 */
public enum FileSystemError: Swift.Error {

    
    
    /**
     * Tried to read a file that doesn't exist
     */
    case FileDoesNotExist
    /**
     * Something went wrong with the filesystem operation
     */
    case IoFailure(String
    )
    /**
     * Filesystem not initialized
     */
    case NotInitialized
    /**
     * Unexpected UniFFI callback error
     */
    case UnexpectedUniFfiCallbackError(String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileSystemError: FfiConverterRustBuffer {
    typealias SwiftType = FileSystemError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FileDoesNotExist
        case 2: return .IoFailure(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .NotInitialized
        case 4: return .UnexpectedUniFfiCallbackError(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileSystemError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .FileDoesNotExist:
            writeInt(&buf, Int32(1))
        
        
        case let .IoFailure(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case .NotInitialized:
            writeInt(&buf, Int32(3))
        
        
        case let .UnexpectedUniFfiCallbackError(v1):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemError_lift(_ buf: RustBuffer) throws -> FileSystemError {
    return try FfiConverterTypeFileSystemError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemError_lower(_ value: FileSystemError) -> RustBuffer {
    return FfiConverterTypeFileSystemError.lower(value)
}


extension FileSystemError: Equatable, Hashable {}




extension FileSystemError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Test error enum to verify `FileSystemError` is automatically included
 */
public enum FileSystemTestError: Swift.Error {

    
    
    /**
     * Custom test error
     */
    case TestError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileSystemTestError: FfiConverterRustBuffer {
    typealias SwiftType = FileSystemTestError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileSystemTestError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .TestError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FileSystemTestError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .TestError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemTestError_lift(_ buf: RustBuffer) throws -> FileSystemTestError {
    return try FfiConverterTypeFileSystemTestError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileSystemTestError_lower(_ value: FileSystemTestError) -> RustBuffer {
    return FfiConverterTypeFileSystemTestError.lower(value)
}


extension FileSystemTestError: Equatable, Hashable {}




extension FileSystemTestError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Represents HTTP-related errors that can occur during network requests.
 */
public enum HttpError: Swift.Error {

    
    
    /**
     * HTTP error with specific status code (4xx, 5xx responses)
     */
    case BadStatusCode(message: String)
    
    /**
     * No internet connectivity available
     */
    case NoConnectivity(message: String)
    
    /**
     * Request timed out
     */
    case Timeout(message: String)
    
    /**
     * DNS resolution failed for the hostname
     */
    case DnsResolutionFailed(message: String)
    
    /**
     * Connection was refused by the server
     */
    case ConnectionRefused(message: String)
    
    /**
     * SSL/TLS certificate validation failed
     */
    case SslError(message: String)
    
    /**
     * The request was cancelled before completion
     */
    case Cancelled(message: String)
    
    /**
     * Generic error for unexpected errors
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpError: FfiConverterRustBuffer {
    typealias SwiftType = HttpError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BadStatusCode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .NoConnectivity(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Timeout(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .DnsResolutionFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .ConnectionRefused(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .SslError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Cancelled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .BadStatusCode(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .NoConnectivity(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Timeout(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .DnsResolutionFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .ConnectionRefused(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .SslError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Cancelled(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpError_lift(_ buf: RustBuffer) throws -> HttpError {
    return try FfiConverterTypeHttpError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpError_lower(_ value: HttpError) -> RustBuffer {
    return FfiConverterTypeHttpError.lower(value)
}


extension HttpError: Equatable, Hashable {}




extension HttpError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * HTTP methods supported by the authenticated HTTP client.
 */

public enum HttpMethod {
    
    /**
     * HTTP GET method for retrieving data
     */
    case get
    /**
     * HTTP POST method for sending data
     */
    case post
}


#if compiler(>=6)
extension HttpMethod: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpMethod: FfiConverterRustBuffer {
    typealias SwiftType = HttpMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpMethod_lift(_ buf: RustBuffer) throws -> HttpMethod {
    return try FfiConverterTypeHttpMethod.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpMethod_lower(_ value: HttpMethod) -> RustBuffer {
    return FfiConverterTypeHttpMethod.lower(value)
}


extension HttpMethod: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enumeration of possible log levels.
 *
 * This enum represents the severity levels that can be used when logging messages.
 */

public enum LogLevel {
    
    /**
     * Designates very low priority, often extremely detailed messages.
     */
    case trace
    /**
     * Designates lower priority debugging information.
     */
    case debug
    /**
     * Designates informational messages that highlight the progress of the application.
     */
    case info
    /**
     * Designates potentially harmful situations.
     */
    case warn
    /**
     * Designates error events that might still allow the application to continue running.
     */
    case error
}


#if compiler(>=6)
extension LogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .trace
        
        case 2: return .debug
        
        case 3: return .info
        
        case 4: return .warn
        
        case 5: return .error
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .trace:
            writeInt(&buf, Int32(1))
        
        
        case .debug:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .warn:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


extension LogLevel: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported blockchain networks for Bedrock operations
 */

public enum Network : UInt32 {
    
    /**
     * Ethereum (chain ID: 1)
     */
    case ethereum = 1
    /**
     * Optimism (chain ID: 10)
     */
    case optimism = 10
    /**
     * World Chain (chain ID: 480)
     */
    case worldChain = 480
}


#if compiler(>=6)
extension Network: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNetwork: FfiConverterRustBuffer {
    typealias SwiftType = Network

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Network {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ethereum
        
        case 2: return .optimism
        
        case 3: return .worldChain
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Network, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ethereum:
            writeInt(&buf, Int32(1))
        
        
        case .optimism:
            writeInt(&buf, Int32(2))
        
        
        case .worldChain:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lift(_ buf: RustBuffer) throws -> Network {
    return try FfiConverterTypeNetwork.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNetwork_lower(_ value: Network) -> RustBuffer {
    return FfiConverterTypeNetwork.lower(value)
}


extension Network: Equatable, Hashable {}







/**
 * Represents primitive errors on Bedrock. These errors may not be called **from** FFI.
 */
public enum PrimitiveError: Swift.Error {

    
    
    /**
     * The provided string is not validly encoded hex data.
     */
    case InvalidHexString(message: String)
    
    /**
     * A provided raw input could not be parsed, is incorrectly formatted, incorrectly encoded or otherwise invalid.
     */
    case InvalidInput(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePrimitiveError: FfiConverterRustBuffer {
    typealias SwiftType = PrimitiveError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PrimitiveError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidHexString(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PrimitiveError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidHexString(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitiveError_lift(_ buf: RustBuffer) throws -> PrimitiveError {
    return try FfiConverterTypePrimitiveError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePrimitiveError_lower(_ value: PrimitiveError) -> RustBuffer {
    return FfiConverterTypePrimitiveError.lower(value)
}


extension PrimitiveError: Equatable, Hashable {}




extension PrimitiveError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Errors that can occur when working with the secure module.
 */
public enum RootKeyError: Swift.Error {

    
    
    /**
     * The provided input is likely not an actual `RootKey`. It is malformed or not the right format.
     */
    case KeyParseError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRootKeyError: FfiConverterRustBuffer {
    typealias SwiftType = RootKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RootKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyParseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RootKeyError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .KeyParseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRootKeyError_lift(_ buf: RustBuffer) throws -> RootKeyError {
    return try FfiConverterTypeRootKeyError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRootKeyError_lower(_ value: RootKeyError) -> RustBuffer {
    return FfiConverterTypeRootKeyError.lower(value)
}


extension RootKeyError: Equatable, Hashable {}




extension RootKeyError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Errors that can occur when interacting with RPC operations.
 */
public enum RpcError: Swift.Error {

    
    
    /**
     * HTTP request failed
     */
    case HttpError(message: String)
    
    /**
     * JSON parsing error
     */
    case JsonError(message: String)
    
    /**
     * RPC returned an error response
     */
    case RpcResponseError(message: String)
    
    /**
     * Invalid response format
     */
    case InvalidResponse(message: String)
    
    /**
     * HTTP client has not been initialized
     */
    case HttpClientNotInitialized(message: String)
    
    /**
     * Primitive operation error
     */
    case PrimitiveError(message: String)
    
    /**
     * Safe Smart Account operation error
     */
    case SafeSmartAccountError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRpcError: FfiConverterRustBuffer {
    typealias SwiftType = RpcError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RpcError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .HttpError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .JsonError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .RpcResponseError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidResponse(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .HttpClientNotInitialized(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .PrimitiveError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .SafeSmartAccountError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RpcError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .HttpError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .JsonError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .RpcResponseError(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidResponse(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .HttpClientNotInitialized(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .PrimitiveError(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .SafeSmartAccountError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRpcError_lift(_ buf: RustBuffer) throws -> RpcError {
    return try FfiConverterTypeRpcError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRpcError_lower(_ value: RpcError) -> RustBuffer {
    return FfiConverterTypeRpcError.lower(value)
}


extension RpcError: Equatable, Hashable {}




extension RpcError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * 4337 provider selection to be passed by native apps
 */

public enum RpcProviderName {
    
    /**
     * Use Alchemy as 4337 provider
     */
    case alchemy
    /**
     * Use Pimlico as 4337 provider
     */
    case pimlico
}


#if compiler(>=6)
extension RpcProviderName: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRpcProviderName: FfiConverterRustBuffer {
    typealias SwiftType = RpcProviderName

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RpcProviderName {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .alchemy
        
        case 2: return .pimlico
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RpcProviderName, into buf: inout [UInt8]) {
        switch value {
        
        
        case .alchemy:
            writeInt(&buf, Int32(1))
        
        
        case .pimlico:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRpcProviderName_lift(_ buf: RustBuffer) throws -> RpcProviderName {
    return try FfiConverterTypeRpcProviderName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRpcProviderName_lower(_ value: RpcProviderName) -> RustBuffer {
    return FfiConverterTypeRpcProviderName.lower(value)
}


extension RpcProviderName: Equatable, Hashable {}






// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of operation to perform on behalf of the Safe Smart Account.
 *
 * Reference: <https://github.com/safe-global/safe-smart-account/blob/v1.4.1/contracts/libraries/Enum.sol#L9>
 */

public enum SafeOperation : UInt8 {
    
    /**
     * Performs a standard message call.
     */
    case call = 0
    /**
     * Performs a `delegatecall`. Executes the target contract’s code in the context of the Safe's storage.
     */
    case delegateCall = 1
}


#if compiler(>=6)
extension SafeOperation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeOperation: FfiConverterRustBuffer {
    typealias SwiftType = SafeOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .call
        
        case 2: return .delegateCall
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SafeOperation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .call:
            writeInt(&buf, Int32(1))
        
        
        case .delegateCall:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeOperation_lift(_ buf: RustBuffer) throws -> SafeOperation {
    return try FfiConverterTypeSafeOperation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeOperation_lower(_ value: SafeOperation) -> RustBuffer {
    return FfiConverterTypeSafeOperation.lower(value)
}


extension SafeOperation: Equatable, Hashable {}







/**
 * Errors that can occur when working with Safe Smart Accounts.
 */
public enum SafeSmartAccountError: Swift.Error {

    
    
    /**
     * Failed to decode a hex-encoded secret key into a k256 signer.
     */
    case KeyDecoding(message: String)
    
    /**
     * Error occurred during the signing process.
     */
    case Signing(message: String)
    
    /**
     * Failed to parse an Ethereum address string.
     */
    case AddressParsing(message: String)
    
    /**
     * Failed to encode data to a specific format.
     */
    case Encoding(message: String)
    
    /**
     * For security reasons, the contract is restricted from directly signing `TypedData`.
     */
    case RestrictedContract(message: String)
    
    /**
     * A provided raw input could not be parsed, is incorrectly formatted, incorrectly encoded or otherwise invalid.
     */
    case InvalidInput(message: String)
    
    /**
     * An error occurred with a primitive type. See `PrimitiveError` for more details.
     */
    case PrimitiveError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSafeSmartAccountError: FfiConverterRustBuffer {
    typealias SwiftType = SafeSmartAccountError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SafeSmartAccountError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyDecoding(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Signing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .AddressParsing(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Encoding(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .RestrictedContract(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidInput(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .PrimitiveError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SafeSmartAccountError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .KeyDecoding(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Signing(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .AddressParsing(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Encoding(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .RestrictedContract(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidInput(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .PrimitiveError(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccountError_lift(_ buf: RustBuffer) throws -> SafeSmartAccountError {
    return try FfiConverterTypeSafeSmartAccountError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSafeSmartAccountError_lower(_ value: SafeSmartAccountError) -> RustBuffer {
    return FfiConverterTypeSafeSmartAccountError.lower(value)
}


extension SafeSmartAccountError: Equatable, Hashable {}




extension SafeSmartAccountError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}





/**
 * Errors that can occur when interacting with transaction operations.
 */
public enum TransactionError: Swift.Error {

    
    
    /**
     * An error occurred with a primitive type. See `PrimitiveError` for more details.
     */
    case PrimitiveError(message: String)
    
    /**
     * A generic error that can wrap any anyhow error.
     */
    case Generic(message: String)
    
    /**
     * Filesystem operation error.
     */
    case FileSystem(message: String)
    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransactionError: FfiConverterRustBuffer {
    typealias SwiftType = TransactionError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .PrimitiveError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .FileSystem(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .PrimitiveError(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .FileSystem(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lift(_ buf: RustBuffer) throws -> TransactionError {
    return try FfiConverterTypeTransactionError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransactionError_lower(_ value: TransactionError) -> RustBuffer {
    return FfiConverterTypeTransactionError.lower(value)
}


extension TransactionError: Equatable, Hashable {}




extension TransactionError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * First byte of the metadata field. Index starts at 1 as 0 is reserved for "not set"
 * NOTE: Ordering should never change, only new values should be added
 */

public enum TransferAssociation : UInt8 {
    
    case none = 1
    case xmtpMessage = 2
}


#if compiler(>=6)
extension TransferAssociation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransferAssociation: FfiConverterRustBuffer {
    typealias SwiftType = TransferAssociation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferAssociation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .xmtpMessage
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferAssociation, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .xmtpMessage:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransferAssociation_lift(_ buf: RustBuffer) throws -> TransferAssociation {
    return try FfiConverterTypeTransferAssociation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransferAssociation_lower(_ value: TransferAssociation) -> RustBuffer {
    return FfiConverterTypeTransferAssociation.lower(value)
}


extension TransferAssociation: Equatable, Hashable {}






#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAuthenticatedHttpClient: FfiConverterRustBuffer {
    typealias SwiftType = AuthenticatedHttpClient?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthenticatedHttpClient.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthenticatedHttpClient.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeBedrockConfig: FfiConverterRustBuffer {
    typealias SwiftType = BedrockConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBedrockConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBedrockConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTransferAssociation: FfiConverterRustBuffer {
    typealias SwiftType = TransferAssociation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTransferAssociation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTransferAssociation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeHttpHeader: FfiConverterRustBuffer {
    typealias SwiftType = [HttpHeader]

    public static func write(_ value: [HttpHeader], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeHttpHeader.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [HttpHeader] {
        let len: Int32 = try readInt(&buf)
        var seq = [HttpHeader]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeHttpHeader.read(from: &buf))
        }
        return seq
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureBedrockInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                uniffiFutureContinuationCallback,
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
private func uniffiTraitInterfaceCallAsync<T>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> ()
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)

}

private func uniffiTraitInterfaceCallAsyncWithError<T, E>(
    makeCall: @escaping () async throws -> T,
    handleSuccess: @escaping (T) -> (),
    handleError: @escaping (Int8, RustBuffer) -> (),
    lowerError: @escaping (E) -> RustBuffer
) -> UniffiForeignFuture {
    let task = Task {
        do {
            handleSuccess(try await makeCall())
        } catch let error as E {
            handleError(CALL_ERROR, lowerError(error))
        } catch {
            handleError(CALL_UNEXPECTED_ERROR, FfiConverterString.lower(String(describing: error)))
        }
    }
    let handle = UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.insert(obj: task)
    return UniffiForeignFuture(handle: handle, free: uniffiForeignFutureFree)
}

// Borrow the callback handle map implementation to store foreign future handles
// TODO: consolidate the handle-map code (https://github.com/mozilla/uniffi-rs/pull/1823)
fileprivate let UNIFFI_FOREIGN_FUTURE_HANDLE_MAP = UniffiHandleMap<UniffiForeignFutureTask>()

// Protocol for tasks that handle foreign futures.
//
// Defining a protocol allows all tasks to be stored in the same handle map.  This can't be done
// with the task object itself, since has generic parameters.
fileprivate protocol UniffiForeignFutureTask {
    func cancel()
}

extension Task: UniffiForeignFutureTask {}

private func uniffiForeignFutureFree(handle: UInt64) {
    do {
        let task = try UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.remove(handle: handle)
        // Set the cancellation flag on the task.  If it's still running, the code can check the
        // cancellation flag or call `Task.checkCancellation()`.  If the task has completed, this is
        // a no-op.
        task.cancel()
    } catch {
        print("uniffiForeignFutureFree: handle missing from handlemap")
    }
}

// For testing
public func uniffiForeignFutureHandleCountBedrock() -> Int {
    UNIFFI_FOREIGN_FUTURE_HANDLE_MAP.count
}
/**
 * Allows to compute the predicted wallet address from the EOA address **only for newly deployed Safe Smart Accounts**.
 *
 * This function uses an algorithm that's specific for v1.4.1 Safe contracts. This function
 * should **NOT be used** for existing World App wallets as they may have been deployed with other
 * parameters. It's safer to rely on the on-chain/backend records for this.
 *
 * Backend reference: <https://github.com/worldcoin/app-backend-main/blob/58c3debef35fb9b283a87c75fab023d6281a019f/src/users-wallets/users-wallets.service.ts#L423>
 *
 * # Errors
 * * `SafeSmartAccountError::InvalidInput` - if the EOA address is invalid.
 */
public func computeWalletAddressForFreshAccount(eoaAddress: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeSafeSmartAccountError_lift) {
    uniffi_bedrock_fn_func_compute_wallet_address_for_fresh_account(
        FfiConverterString.lower(eoaAddress),$0
    )
})
}
/**
 * Gets a reference to the global Bedrock configuration.
 *
 * # Returns
 * An Option containing a reference to the config if initialized, None otherwise.
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * if let config = getConfig() {
 * print("Environment: \(config.environment())")
 * }
 * ```
 */
public func getConfig() -> BedrockConfig?  {
    return try!  FfiConverterOptionTypeBedrockConfig.lift(try! rustCall() {
    uniffi_bedrock_fn_func_get_config($0
    )
})
}
/**
 * Gets a reference to the global HTTP client instance.
 *
 * # Returns
 * An Option containing a reference to the HTTP client if initialized, None otherwise.
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * if let httpClient = getHttpClient() {
 * // Use the HTTP client
 * }
 * ```
 */
public func getHttpClient() -> AuthenticatedHttpClient?  {
    return try!  FfiConverterOptionTypeAuthenticatedHttpClient.lift(try! rustCall() {
    uniffi_bedrock_fn_func_get_http_client($0
    )
})
}
/**
 * Returns whether a foreign `BackupServiceApi` has been configured.
 */
public func isBackupServiceApiInitialized() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_is_backup_service_api_initialized($0
    )
})
}
/**
 * Checks if the HTTP client has been initialized.
 *
 * # Returns
 * true if the HTTP client has been initialized, false otherwise.
 */
public func isHttpClientInitialized() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_is_http_client_initialized($0
    )
})
}
/**
 * Checks if the Bedrock configuration has been initialized.
 *
 * # Returns
 * true if the config has been initialized, false otherwise.
 */
public func isInitialized() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_is_initialized($0
    )
})
}
/**
 * Sets the global `BackupServiceApi` instance.
 */
public func setBackupServiceApi(api: BackupServiceApi) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_set_backup_service_api(
        FfiConverterTypeBackupServiceApi_lower(api),$0
    )
})
}
/**
 * Initializes the global Bedrock configuration.
 *
 * This function should be called once at application startup before any other Bedrock operations.
 * Subsequent calls will be ignored and print a warning.
 *
 * # Arguments
 * * `environment` - The environment to use for all Bedrock operations
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * import Bedrock
 *
 * // In your app delegate or during app initialization
 * setConfig(environment: .staging)
 * ```
 */
public func setConfig(environment: BedrockEnvironment)  {try! rustCall() {
    uniffi_bedrock_fn_func_set_config(
        FfiConverterTypeBedrockEnvironment_lower(environment),$0
    )
}
}
/**
 * Sets the global filesystem instance
 *
 * This function allows you to provide your own implementation of the `FileSystem` trait.
 * It should be called once during application initialization.
 *
 * # Arguments
 *
 * * `filesystem` - An `Arc` containing your filesystem implementation.
 *
 * # Note
 *
 * If the filesystem has already been set, this function will print a message and do nothing.
 */
public func setFilesystem(filesystem: FileSystem)  {try! rustCall() {
    uniffi_bedrock_fn_func_set_filesystem(
        FfiConverterTypeFileSystem_lower(filesystem),$0
    )
}
}
/**
 * Sets the global HTTP client instance.
 *
 * This function allows you to provide your own implementation of the `AuthenticatedHttpClient` trait.
 * It should be called once at application startup before any HTTP operations.
 *
 * # Arguments
 *
 * * `http_client` - An `Arc` containing your HTTP client implementation.
 *
 * # Note
 *
 * If the HTTP client has already been set, this function will do nothing and return false.
 *
 * # Examples
 *
 * ## Swift
 *
 * ```swift
 * let httpClient = MyHttpClient()
 * let success = setHttpClient(httpClient: httpClient)
 * ```
 */
public func setHttpClient(httpClient: AuthenticatedHttpClient) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_bedrock_fn_func_set_http_client(
        FfiConverterTypeAuthenticatedHttpClient_lower(httpClient),$0
    )
})
}
/**
 * Sets the global logger.
 *
 * This function allows you to provide your own implementation of the `Logger` trait.
 * It initializes the logging system and should be called before any logging occurs.
 *
 * # Arguments
 *
 * * `logger` - An `Arc` containing your logger implementation.
 *
 * # Panics
 *
 * Panics if the logger has already been set.
 *
 * # Note
 *
 * If the logger has already been set, this function will print a message and do nothing.
 */
public func setLogger(logger: Logger)  {try! rustCall() {
    uniffi_bedrock_fn_func_set_logger(
        FfiConverterTypeLogger_lower(logger),$0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 29
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bedrock_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_bedrock_checksum_func_compute_wallet_address_for_fresh_account() != 49783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_get_config() != 37061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_get_http_client() != 47842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_is_backup_service_api_initialized() != 55301) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_is_http_client_initialized() != 39826) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_is_initialized() != 58806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_backup_service_api() != 64228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_config() != 25999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_filesystem() != 48486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_http_client() != 61435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_func_set_logger() != 47849) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_authenticatedhttpclient_fetch_from_app_backend() != 24189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupmanager_add_new_factor() != 13118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupmanager_create_sealed_backup_for_new_user() != 51722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupmanager_decrypt_and_unpack_sealed_backup() != 30187) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupmanager_post_delete_backup() != 63845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupserviceapi_sync() != 58245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_backupserviceapi_retrieve_metadata() != 33523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_bedrockaddress_as_abi_encode() != 44498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_bedrockaddress_as_abi_encode_packed() != 29676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_bedrockaddress_as_checksummed_str() != 54556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_bedrockconfig_environment() != 53973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_enclaveattestationverifier_verify_attestation_document_and_encrypt() != 42656) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_enclaveattestationverifier_verify_attestation_document_base64() != 59047) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_file_exists() != 29331) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_read_file() != 33257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_list_files_at_directory() != 43568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_read_file_range() != 28178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_write_file() != 21027) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystem_delete_file() != 41764) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystemtester_test_delete_file() != 61617) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystemtester_test_file_exists() != 11185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystemtester_test_list_files_at_directory() != 55640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystemtester_test_read_file() != 34530) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_filesystemtester_test_write_file() != 12203) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_hexencodeddata_to_hex_string() != 53475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_hexencodeddata_to_vec() != 19048) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_logger_log() != 30465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_manifestmanager_list_files() != 62425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_manifestmanager_remove_file() != 20375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_manifestmanager_replace_all_files_for_designator() != 31175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_manifestmanager_store_file() != 35335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_rootkey_is_equal_to() != 2010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_rootkey_is_v0() != 36834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_personal_sign() != 21352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_4337_op() != 4646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_permit2_transfer() != 839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_transaction() != 18163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_sign_typed_data() != 43822) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_safesmartaccount_transaction_transfer() != 61864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_async_operation() != 60685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_authenticate() != 11263) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_generic_operation() != 47303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_demo_mixed_operation() != 58510) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_get_demo_result() != 19522) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_log_message() != 550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_method_toolingdemo_test_log_levels() != 43380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_backupmanager_new() != 42541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_bedrockaddress_new() != 15876) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_bedrockconfig_new() != 53259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_enclaveattestationverifier_new() != 12205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_filesystemtester_new() != 12987) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_hexencodeddata_new() != 40879) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_manifestmanager_new() != 11752) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_rootkey_from_json() != 2594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_rootkey_new_random() != 52627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_safesmartaccount_new() != 38977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_bedrock_checksum_constructor_toolingdemo_new() != 46711) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAuthenticatedHttpClient()
    uniffiCallbackInitBackupServiceApi()
    uniffiCallbackInitFileSystem()
    uniffiCallbackInitLogger()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureBedrockInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all